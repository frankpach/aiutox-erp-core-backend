"""Tasks router for task management."""

import logging
from typing import Annotated
from uuid import UUID

from fastapi import APIRouter, Body, Depends, Path, Query, status
from sqlalchemy.orm import Session

from app.core.auth.dependencies import require_permission
from app.core.config.service import ConfigService
from app.core.db.deps import get_db
from app.core.exceptions import APIException
from app.core.tasks.service import TaskService, get_task_service
from app.models.user import User
from app.schemas.common import PaginationMeta, StandardListResponse, StandardResponse
from app.schemas.task import (
    TaskCreate,
    TaskModuleSettings,
    TaskModuleSettingsUpdate,
    TaskResponse,
    TaskUpdate,
)

# Import modular routers
from app.modules.tasks.routers import (
    tasks_analytics,
    tasks_assignments,
    tasks_calendar,
    tasks_checklist,
    tasks_comments,
    tasks_core,
    tasks_dependencies,
    tasks_files,
    tasks_preferences,
    tasks_status,
    tasks_tags,
)

logger = logging.getLogger(__name__)

# Main router
router = APIRouter()

# Include all modular routers
router.include_router(tasks_core.router, prefix="/tasks", tags=["tasks"])
router.include_router(tasks_checklist.router, prefix="/tasks", tags=["tasks-checklist"])
router.include_router(tasks_assignments.router, prefix="/tasks", tags=["tasks-assignments"])
router.include_router(tasks_calendar.router, prefix="/tasks", tags=["tasks-calendar"])
router.include_router(tasks_status.router, prefix="/tasks", tags=["tasks-status"])
router.include_router(tasks_files.router, prefix="/tasks", tags=["tasks-files"])
router.include_router(tasks_comments.router, prefix="/tasks", tags=["tasks-comments"])
router.include_router(tasks_tags.router, prefix="/tasks", tags=["tasks-tags"])
router.include_router(tasks_analytics.router, prefix="/tasks", tags=["tasks-analytics"])
router.include_router(tasks_dependencies.router, prefix="/tasks", tags=["tasks-dependencies"])
router.include_router(tasks_preferences.router, prefix="/tasks", tags=["tasks-preferences"])

# Legacy endpoints that haven't been migrated yet
TASK_SETTINGS_KEYS = {
    "calendar_enabled": "calendar.enabled",
    "board_enabled": "board.enabled",
    "inbox_enabled": "inbox.enabled",
    "list_enabled": "list.enabled",
    "gantt_enabled": "gantt.enabled",
    "calendar_auto_sync": "calendar.auto_sync",
    "default_priority": "tasks.default_priority",
    "default_status": "tasks.default_status",
    "task_auto_numbering": "tasks.auto_numbering",
    "task_number_prefix": "tasks.number_prefix",
    "task_number_separator": "tasks.number_separator",
    "allow_task_dependencies": "tasks.allow_dependencies",
    "require_dependency_resolution": "tasks.require_dependency_resolution",
    "max_task_depth": "tasks.max_depth",
    "enable_task_templates": "tasks.enable_templates",
    "default_task_duration": "tasks.default_duration",
    "enable_task_reminders": "tasks.enable_reminders",
    "default_reminder_time": "tasks.default_reminder_time",
    "enable_task_comments": "tasks.enable_comments",
    "enable_task_files": "tasks.enable_files",
    "max_file_size": "tasks.max_file_size",
    "allowed_file_types": "tasks.allowed_file_types",
    "enable_task_tags": "tasks.enable_tags",
    "max_tags_per_task": "tasks.max_tags_per_task",
    "enable_task_checklist": "tasks.enable_checklist",
    "max_checklist_items": "tasks.max_checklist_items",
    "enable_task_assignments": "tasks.enable_assignments",
    "max_assignees_per_task": "tasks.max_assignees_per_task",
    "enable_task_history": "tasks.enable_history",
    "history_retention_days": "tasks.history_retention_days",
}


def _build_task_settings(settings: dict) -> TaskModuleSettings:
    """Build task module settings from configuration."""
    return TaskModuleSettings(
        calendar_enabled=settings.get(TASK_SETTINGS_KEYS["calendar_enabled"], False),
        board_enabled=settings.get(TASK_SETTINGS_KEYS["board_enabled"], False),
        inbox_enabled=settings.get(TASK_SETTINGS_KEYS["inbox_enabled"], False),
        list_enabled=settings.get(TASK_SETTINGS_KEYS["list_enabled"], False),
        gantt_enabled=settings.get(TASK_SETTINGS_KEYS["gantt_enabled"], False),
        calendar_auto_sync=settings.get(TASK_SETTINGS_KEYS["calendar_auto_sync"], False),
        default_priority=settings.get(TASK_SETTINGS_KEYS["default_priority"], "medium"),
        default_status=settings.get(TASK_SETTINGS_KEYS["default_status"], "todo"),
        task_auto_numbering=settings.get(TASK_SETTINGS_KEYS["task_auto_numbering"], False),
        task_number_prefix=settings.get(TASK_SETTINGS_KEYS["task_number_prefix"], "TASK-"),
        task_number_separator=settings.get(TASK_SETTINGS_KEYS["task_number_separator"], "-"),
        allow_task_dependencies=settings.get(TASK_SETTINGS_KEYS["allow_task_dependencies"], True),
        require_dependency_resolution=settings.get(TASK_SETTINGS_KEYS["require_dependency_resolution"], False),
        max_task_depth=settings.get(TASK_SETTINGS_KEYS["max_task_depth"], 5),
        enable_task_templates=settings.get(TASK_SETTINGS_KEYS["enable_task_templates"], False),
        default_task_duration=settings.get(TASK_SETTINGS_KEYS["default_task_duration"], 60),
        enable_task_reminders=settings.get(TASK_SETTINGS_KEYS["enable_task_reminders"], True),
        default_reminder_time=settings.get(TASK_SETTINGS_KEYS["default_reminder_time"], 15),
        enable_task_comments=settings.get(TASK_SETTINGS_KEYS["enable_task_comments"], True),
        enable_task_files=settings.get(TASK_SETTINGS_KEYS["enable_task_files"], True),
        max_file_size=settings.get(TASK_SETTINGS_KEYS["max_file_size"], 10485760),  # 10MB
        allowed_file_types=settings.get(TASK_SETTINGS_KEYS["allowed_file_types"], [".pdf", ".doc", ".docx", ".txt", ".jpg", ".png"]),
        enable_task_tags=settings.get(TASK_SETTINGS_KEYS["enable_task_tags"], True),
        max_tags_per_task=settings.get(TASK_SETTINGS_KEYS["max_tags_per_task"], 10),
        enable_task_checklist=settings.get(TASK_SETTINGS_KEYS["enable_task_checklist"], True),
        max_checklist_items=settings.get(TASK_SETTINGS_KEYS["max_checklist_items"], 20),
        enable_task_assignments=settings.get(TASK_SETTINGS_KEYS["enable_task_assignments"], True),
        max_assignees_per_task=settings.get(TASK_SETTINGS_KEYS["max_assignees_per_task"], 5),
        enable_task_history=settings.get(TASK_SETTINGS_KEYS["enable_task_history"], True),
        history_retention_days=settings.get(TASK_SETTINGS_KEYS["history_retention_days"], 90),
    )


@router.get(
    "/settings",
    response_model=StandardResponse[TaskModuleSettings],
    status_code=status.HTTP_200_OK,
    summary="Get task module settings",
    description="Get task module settings for the tenant. Requires tasks.view permission.",
)
async def get_task_settings(
    current_user: Annotated[User, Depends(require_permission("tasks.view"))],
    db: Annotated[Session, Depends(get_db)],
) -> StandardResponse[TaskModuleSettings]:
    """Get task module settings."""
    config_service = ConfigService(db)
    settings = config_service.get_module_settings(
        tenant_id=current_user.tenant_id,
        module_name="tasks"
    )

    task_settings = _build_task_settings(settings)

    return StandardResponse(
        data=task_settings,
        message="Task settings retrieved successfully",
    )


@router.put(
    "/settings",
    response_model=StandardResponse[TaskModuleSettings],
    status_code=status.HTTP_200_OK,
    summary="Update task module settings",
    description="Update task module settings for the tenant. Requires tasks.manage permission.",
)
async def update_task_settings(
    settings_update: TaskModuleSettingsUpdate,
    current_user: Annotated[User, Depends(require_permission("tasks.manage"))],
    db: Annotated[Session, Depends(get_db)],
) -> StandardResponse[TaskModuleSettings]:
    """Update task module settings."""
    config_service = ConfigService(db)

    # Convert settings update to config format
    update_dict = settings_update.model_dump(exclude_unset=True)
    config_updates = {}

    for key, value in update_dict.items():
        if key in TASK_SETTINGS_KEYS:
            config_updates[TASK_SETTINGS_KEYS[key]] = value

    # Update settings
    config_service.update_module_settings(
        tenant_id=current_user.tenant_id,
        module_name="tasks",
        settings=config_updates
    )

    # Get updated settings
    updated_settings = config_service.get_module_settings(
        tenant_id=current_user.tenant_id,
        module_name="tasks"
    )

    task_settings = _build_task_settings(updated_settings)

    return StandardResponse(
        data=task_settings,
        message="Task settings updated successfully",
    )


# Legacy get_task endpoint (still in main file)
@router.get(
    "/{task_id}",
    response_model=StandardResponse[TaskResponse],
    status_code=status.HTTP_200_OK,
    summary="Get task",
    description="Get a specific task by ID. Requires tasks.view permission.",
)
async def get_task(
    task_id: Annotated[UUID, Path(..., description="Task ID")],
    current_user: Annotated[User, Depends(require_permission("tasks.view"))],
    service: Annotated[TaskService, Depends(get_task_service)],
) -> StandardResponse[TaskResponse]:
    """Get a specific task."""
    task = service.get_task(task_id, current_user.tenant_id)

    if not task:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="TASK_NOT_FOUND",
            message=f"Task with ID {task_id} not found",
        )

    return StandardResponse(
        data=TaskResponse.model_validate(task),
        message="Task retrieved successfully",
    )


@router.get(
    "",
    response_model=StandardListResponse[TaskResponse],
    status_code=status.HTTP_200_OK,
    summary="List tasks",
    description="List tasks with optional filters. Requires tasks.view permission.",
)
async def list_tasks(
    current_user: Annotated[User, Depends(require_permission("tasks.view"))],
    service: Annotated[TaskService, Depends(get_task_service)],
    page: int = Query(default=1, ge=1, description="Page number"),
    page_size: int = Query(default=20, ge=1, le=100, description="Page size"),
    status: str | None = Query(default=None, description="Filter by status"),
    priority: str | None = Query(default=None, description="Filter by priority"),
    assigned_to_id: UUID | None = Query(default=None, description="Filter by assigned user"),
) -> StandardListResponse[TaskResponse]:
    """List tasks."""
    skip = (page - 1) * page_size
    tasks = service.get_tasks(
        tenant_id=current_user.tenant_id,
        status=status,
        priority=priority,
        assigned_to_id=assigned_to_id,
        skip=skip,
        limit=page_size,
    )
    total = len(tasks)

    total_pages = (total + page_size - 1) // page_size if total > 0 else 0

    return StandardListResponse(
        data=[TaskResponse.model_validate(t) for t in tasks],
        meta={
            "total": total,
            "page": page,
            "page_size": page_size,
            "total_pages": total_pages,
        },
        message="Tasks retrieved successfully",
    )


# Special endpoints (must come BEFORE parametrized routes)
@router.get(
    "/my-tasks",
    response_model=StandardListResponse[TaskResponse],
    status_code=status.HTTP_200_OK,
    summary="List my tasks",
    description="List tasks visible to current user (created by user or assigned to user). Requires tasks.view permission.",
)
async def list_my_tasks(
    current_user: Annotated[User, Depends(require_permission("tasks.view"))],
    service: Annotated[TaskService, Depends(get_task_service)],
    page: int = Query(default=1, ge=1, description="Page number"),
    page_size: int = Query(default=20, ge=1, le=100, description="Page size"),
    status: str | None = Query(default=None, description="Filter by status"),
    priority: str | None = Query(default=None, description="Filter by priority"),
) -> StandardListResponse[TaskResponse]:
    """List tasks visible to current user."""
    skip = (page - 1) * page_size
    tasks = service.repository.get_visible_tasks(
        tenant_id=current_user.tenant_id,
        user_id=current_user.id,
        status=status,
        priority=priority,
        skip=skip,
        limit=page_size,
    )
    total = service.repository.count_visible_tasks(
        tenant_id=current_user.tenant_id,
        user_id=current_user.id,
        status=status,
        priority=priority,
    )

    total_pages = (total + page_size - 1) // page_size if total > 0 else 0

    return StandardListResponse(
        data=[TaskResponse.model_validate(t) for t in tasks],
        meta=PaginationMeta(
            total=total,
            page=page,
            page_size=page_size,
            total_pages=total_pages,
        ),
    )


@router.get(
    "/settings",
    response_model=StandardResponse[TaskModuleSettings],
    status_code=status.HTTP_200_OK,
    summary="Get tasks settings",
    description="Get tasks module settings for the tenant. Requires tasks.view permission.",
)
async def get_task_settings(
    current_user: Annotated[User, Depends(require_permission("tasks.view"))],
    db: Annotated[Session, Depends(get_db)],
) -> StandardResponse[TaskModuleSettings]:
    """Get tasks module settings for the current tenant."""
    config_service = ConfigService(db)
    settings = _build_task_settings(config_service, current_user.tenant_id)
    return StandardResponse(
        data=settings,
        message="Tasks settings retrieved successfully",
    )


@router.put(
    "/settings",
    response_model=StandardResponse[TaskModuleSettings],
    status_code=status.HTTP_200_OK,
    summary="Update tasks settings",
    description="Update tasks module settings for the tenant. Requires tasks.manage permission.",
)
async def update_task_settings(
    settings: TaskModuleSettingsUpdate,
    current_user: Annotated[User, Depends(require_permission("tasks.manage"))],
    db: Annotated[Session, Depends(get_db)],
) -> StandardResponse[TaskModuleSettings]:
    """Update tasks module settings for the current tenant."""
    config_service = ConfigService(db)
    update_data = settings.model_dump(exclude_unset=True)
    if update_data:
        config_updates = {
            TASK_SETTINGS_KEYS[key]: value for key, value in update_data.items()
        }
        config_service.set_module_config(
            tenant_id=current_user.tenant_id,
            module="tasks",
            config_dict=config_updates,
            user_id=current_user.id,
        )

    refreshed_settings = _build_task_settings(config_service, current_user.tenant_id)
    return StandardResponse(
        data=refreshed_settings,
        message="Tasks settings updated successfully",
    )




@router.put(
    "/{task_id}",
    response_model=StandardResponse[TaskResponse],
    status_code=status.HTTP_200_OK,
    summary="Update task",
    description="Update a task. Requires tasks.manage permission.",
)
async def update_task(
    task_id: Annotated[UUID, Path(..., description="Task ID")],
    current_user: Annotated[User, Depends(require_permission("tasks.manage"))],
    service: Annotated[TaskService, Depends(get_task_service)],
    task_data: TaskUpdate,
) -> StandardResponse[TaskResponse]:
    """Update a task."""
    update_dict = task_data.model_dump(exclude_unset=True)
    task = service.update_task(task_id, current_user.tenant_id, update_dict, current_user.id)

    if not task:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="TASK_NOT_FOUND",
            message=f"Task with ID {task_id} not found",
        )

    return StandardResponse(
        data=TaskResponse.model_validate(task),
        message="Task updated successfully",
    )


@router.delete(
    "/{task_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Delete task",
    description="Delete a task. Requires tasks.manage permission.",
)
async def delete_task(
    task_id: Annotated[UUID, Path(..., description="Task ID")],
    current_user: Annotated[User, Depends(require_permission("tasks.manage"))],
    service: Annotated[TaskService, Depends(get_task_service)],
) -> None:
    """Delete a task."""
    deleted = await service.delete_task(task_id, current_user.tenant_id, current_user.id)
    if not deleted:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="TASK_NOT_FOUND",
            message=f"Task with ID {task_id} not found",
        )


@router.post(
    "/{task_id}/checklist",
    response_model=StandardResponse[TaskChecklistItemResponse],
    status_code=status.HTTP_201_CREATED,
    summary="Add checklist item",
    description="Add a checklist item to a task. Requires tasks.manage permission.",
)
async def add_checklist_item(
    task_id: Annotated[UUID, Path(..., description="Task ID")],
    current_user: Annotated[User, Depends(require_permission("tasks.manage"))],
    service: Annotated[TaskService, Depends(get_task_service)],
    item_data: TaskChecklistItemCreate,
) -> StandardResponse[TaskChecklistItemResponse]:
    """Add a checklist item to a task."""
    task = service.get_task(task_id, current_user.tenant_id)
    if not task:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="TASK_NOT_FOUND",
            message=f"Task with ID {task_id} not found",
        )

    item = service.add_checklist_item(
        task_id=task_id,
        tenant_id=current_user.tenant_id,
        title=item_data.title,
        order=item_data.order,
    )

    return StandardResponse(
        data=TaskChecklistItemResponse.model_validate(item),
        message="Checklist item added successfully",
    )


@router.get(
    "/{task_id}/checklist",
    response_model=StandardListResponse[TaskChecklistItemResponse],
    status_code=status.HTTP_200_OK,
    summary="List checklist items",
    description="List checklist items for a task. Requires tasks.view permission.",
)
async def list_checklist_items(
    task_id: Annotated[UUID, Path(..., description="Task ID")],
    current_user: Annotated[User, Depends(require_permission("tasks.view"))],
    service: Annotated[TaskService, Depends(get_task_service)],
) -> StandardListResponse[TaskChecklistItemResponse]:
    """List checklist items for a task."""
    items = service.get_checklist_items(task_id, current_user.tenant_id)

    return StandardListResponse(
        data=[TaskChecklistItemResponse.model_validate(i) for i in items],
        meta={
            "total": len(items),
            "page": 1,
            "page_size": max(1, len(items)) if len(items) > 0 else 20,
            "total_pages": 1,
        },
        message="Checklist items retrieved successfully",
    )


@router.put(
    "/checklist/{item_id}",
    response_model=StandardResponse[TaskChecklistItemResponse],
    status_code=status.HTTP_200_OK,
    summary="Update checklist item",
    description="Update a checklist item. Requires tasks.manage permission.",
)
async def update_checklist_item(
    item_id: Annotated[UUID, Path(..., description="Checklist item ID")],
    current_user: Annotated[User, Depends(require_permission("tasks.manage"))],
    service: Annotated[TaskService, Depends(get_task_service)],
    item_data: TaskChecklistItemUpdate,
) -> StandardResponse[TaskChecklistItemResponse]:
    """Update a checklist item."""
    update_dict = item_data.model_dump(exclude_unset=True)
    item = service.update_checklist_item(item_id, current_user.tenant_id, update_dict)

    if not item:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="CHECKLIST_ITEM_NOT_FOUND",
            message=f"Checklist item with ID {item_id} not found",
        )

    return StandardResponse(
        data=TaskChecklistItemResponse.model_validate(item),
        message="Checklist item updated successfully",
    )


@router.delete(
    "/checklist/{item_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Delete checklist item",
    description="Delete a checklist item. Requires tasks.manage permission.",
)
async def delete_checklist_item(
    item_id: Annotated[UUID, Path(..., description="Checklist item ID")],
    current_user: Annotated[User, Depends(require_permission("tasks.manage"))],
    service: Annotated[TaskService, Depends(get_task_service)],
) -> None:
    """Delete a checklist item."""
    deleted = service.delete_checklist_item(item_id, current_user.tenant_id)
    if not deleted:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="CHECKLIST_ITEM_NOT_FOUND",
            message=f"Checklist item with ID {item_id} not found",
        )


@router.post(
    "/{task_id}/assignments",
    response_model=StandardResponse[TaskAssignmentResponse],
    status_code=status.HTTP_201_CREATED,
    summary="Assign user or group to task",
    description="Assign a user or group to a task. Requires tasks.assign permission.",
)
async def create_assignment(
    task_id: Annotated[UUID, Path(..., description="Task ID")],
    assignment_data: TaskAssignmentCreate,
    current_user: Annotated[User, Depends(require_permission("tasks.assign"))],
    service: Annotated[TaskService, Depends(get_task_service)],
) -> StandardResponse[TaskAssignmentResponse]:
    """Create a task assignment."""
    task = service.get_task(task_id, current_user.tenant_id)
    if not task:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="TASK_NOT_FOUND",
            message=f"Task with ID {task_id} not found",
        )

    assignment = service.repository.create_assignment(
        {
            "task_id": task_id,
            "tenant_id": current_user.tenant_id,
            "assigned_to_id": assignment_data.assigned_to_id,
            "assigned_to_group_id": assignment_data.assigned_to_group_id,
            "assigned_by_id": current_user.id,
            "role": assignment_data.role,
            "notes": assignment_data.notes,
        }
    )

    return StandardResponse(
        data=TaskAssignmentResponse.model_validate(assignment),
        message="Assignment created successfully",
    )


@router.get(
    "/{task_id}/assignments",
    response_model=StandardListResponse[TaskAssignmentResponse],
    status_code=status.HTTP_200_OK,
    summary="List task assignments",
    description="List all assignments for a task. Requires tasks.view permission.",
)
async def list_assignments(
    task_id: Annotated[UUID, Path(..., description="Task ID")],
    current_user: Annotated[User, Depends(require_permission("tasks.view"))],
    service: Annotated[TaskService, Depends(get_task_service)],
) -> StandardListResponse[TaskAssignmentResponse]:
    """List assignments for a task."""
    task = service.get_task(task_id, current_user.tenant_id)
    if not task:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="TASK_NOT_FOUND",
            message=f"Task with ID {task_id} not found",
        )

    assignments = service.repository.get_assignments_by_task(task_id, current_user.tenant_id)

    return StandardListResponse(
        data=[TaskAssignmentResponse.model_validate(a) for a in assignments],
        meta={
            "total": len(assignments),
            "page": 1,
            "page_size": max(1, len(assignments)) if len(assignments) > 0 else 20,
            "total_pages": 1,
        },
        message="Assignments retrieved successfully",
    )


@router.delete(
    "/{task_id}/assignments/{assignment_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Remove assignment",
    description="Remove a user or group assignment from a task. Requires tasks.assign permission.",
)
async def remove_assignment(
    task_id: Annotated[UUID, Path(..., description="Task ID")],
    assignment_id: Annotated[UUID, Path(..., description="Assignment ID")],
    current_user: Annotated[User, Depends(require_permission("tasks.assign"))],
    service: Annotated[TaskService, Depends(get_task_service)],
) -> None:
    """Remove a task assignment."""
    task = service.get_task(task_id, current_user.tenant_id)
    if not task:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="TASK_NOT_FOUND",
            message=f"Task with ID {task_id} not found",
        )

    deleted = service.repository.delete_assignment(assignment_id, current_user.tenant_id)
    if not deleted:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="ASSIGNMENT_NOT_FOUND",
            message=f"Assignment with ID {assignment_id} not found",
        )


# Calendar Sync Endpoints (Sprint 1 - Fase 2)


@router.post(
    "/{task_id}/sync-calendar",
    response_model=StandardResponse[dict],
    status_code=status.HTTP_200_OK,
    summary="Sync task to calendar",
    description="Sync a task to calendar. Requires tasks.manage permission.",
)
async def sync_task_to_calendar(
    task_id: Annotated[UUID, Path(..., description="Task ID")],
    current_user: Annotated[User, Depends(require_permission("tasks.manage"))],
    db: Annotated[Session, Depends(get_db)],
    calendar_provider: str = Query(default="internal", description="Calendar provider"),
    calendar_id: str | None = Query(default=None, description="Calendar ID"),
) -> StandardResponse[dict]:
    """Sync task to calendar."""
    sync_service = get_task_event_sync_service(db)

    try:
        result = await sync_service.sync_task_to_calendar(
            task_id=task_id,
            tenant_id=current_user.tenant_id,
            user_id=current_user.id,
            calendar_provider=calendar_provider,
            calendar_id=calendar_id,
        )

        return StandardResponse(
            data=result,
            message="Task synced to calendar successfully",
        )
    except ValueError as e:
        raise APIException(
            status_code=status.HTTP_400_BAD_REQUEST,
            code="SYNC_ERROR",
            message=str(e),
        )


@router.delete(
    "/{task_id}/sync-calendar",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Unsync task from calendar",
    description="Remove calendar sync for a task. Requires tasks.manage permission.",
)
async def unsync_task_from_calendar(
    task_id: Annotated[UUID, Path(..., description="Task ID")],
    current_user: Annotated[User, Depends(require_permission("tasks.manage"))],
    db: Annotated[Session, Depends(get_db)],
) -> None:
    """Unsync task from calendar."""
    sync_service = get_task_event_sync_service(db)

    success = await sync_service.unsync_task_from_calendar(
        task_id=task_id,
        tenant_id=current_user.tenant_id,
        user_id=current_user.id,
    )

    if not success:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="TASK_NOT_FOUND",
            message=f"Task with ID {task_id} not found",
        )


@router.get(
    "/{task_id}/sync-status",
    response_model=StandardResponse[dict],
    status_code=status.HTTP_200_OK,
    summary="Get calendar sync status",
    description="Get calendar sync status for a task. Requires tasks.view permission.",
)
async def get_calendar_sync_status(
    task_id: Annotated[UUID, Path(..., description="Task ID")],
    current_user: Annotated[User, Depends(require_permission("tasks.view"))],
    db: Annotated[Session, Depends(get_db)],
) -> StandardResponse[dict]:
    """Get calendar sync status."""
    sync_service = get_task_event_sync_service(db)

    status_data = sync_service.get_sync_status(
        task_id=task_id,
        tenant_id=current_user.tenant_id,
    )

    return StandardResponse(
        data=status_data,
        message="Sync status retrieved successfully",
    )


@router.post(
    "/sync-batch",
    response_model=StandardResponse[dict],
    status_code=status.HTTP_200_OK,
    summary="Sync multiple tasks to calendar",
    description="Sync multiple tasks to calendar in batch. Requires tasks.manage permission.",
)
async def sync_batch_tasks(
    current_user: Annotated[User, Depends(require_permission("tasks.manage"))],
    db: Annotated[Session, Depends(get_db)],
    task_ids: list[UUID] = Query(..., description="List of task IDs"),
    calendar_provider: str = Query(default="internal", description="Calendar provider"),
    calendar_id: str | None = Query(default=None, description="Calendar ID"),
) -> StandardResponse[dict]:
    """Sync multiple tasks to calendar."""
    sync_service = get_task_event_sync_service(db)

    result = await sync_service.sync_batch_tasks(
        task_ids=task_ids,
        tenant_id=current_user.tenant_id,
        user_id=current_user.id,
        calendar_provider=calendar_provider,
        calendar_id=calendar_id,
    )

    return StandardResponse(
        data=result,
        message=f"Batch sync completed: {len(result['synced'])} synced, "
                f"{len(result['skipped'])} skipped, {len(result['failed'])} failed",
    )


# Task Status Endpoints (Sprint 2 - Fase 2)


@router.get(
    "/status-definitions",
    response_model=StandardListResponse[TaskStatusResponse],
    status_code=status.HTTP_200_OK,
    summary="List task status definitions",
    description="List all task status definitions for the tenant. Requires tasks.view permission.",
)
async def list_status_definitions(
    current_user: Annotated[User, Depends(require_permission("tasks.view"))],
    db: Annotated[Session, Depends(get_db)],
) -> StandardListResponse[TaskStatusResponse]:
    """List task status definitions."""
    status_service = get_task_status_service(db)
    statuses = status_service.get_statuses(current_user.tenant_id)

    return StandardListResponse(
        data=[TaskStatusResponse.model_validate(s) for s in statuses],
        meta={
            "total": len(statuses),
            "page": 1,
            "page_size": len(statuses) if len(statuses) > 0 else 20,
            "total_pages": 1,
        },
        message="Status definitions retrieved successfully",
    )


@router.post(
    "/status-definitions",
    response_model=StandardResponse[TaskStatusResponse],
    status_code=status.HTTP_201_CREATED,
    summary="Create task status definition",
    description="Create a new task status definition. Requires tasks.manage permission.",
)
async def create_status_definition(
    status_data: TaskStatusCreate,
    current_user: Annotated[User, Depends(require_permission("tasks.manage"))],
    db: Annotated[Session, Depends(get_db)],
) -> StandardResponse[TaskStatusResponse]:
    """Create task status definition."""
    status_service = get_task_status_service(db)

    new_status = status_service.create_status(
        tenant_id=current_user.tenant_id,
        name=status_data.name,
        status_type=status_data.type,
        color=status_data.color,
        order=status_data.order,
    )

    return StandardResponse(
        data=TaskStatusResponse.model_validate(new_status),
        message="Status definition created successfully",
    )


@router.put(
    "/status-definitions/{status_id}",
    response_model=StandardResponse[TaskStatusResponse],
    status_code=status.HTTP_200_OK,
    summary="Update task status definition",
    description="Update a task status definition. Cannot update system statuses. Requires tasks.manage permission.",
)
async def update_status_definition(
    status_id: Annotated[UUID, Path(..., description="Status ID")],
    status_data: TaskStatusUpdate,
    current_user: Annotated[User, Depends(require_permission("tasks.manage"))],
    db: Annotated[Session, Depends(get_db)],
) -> StandardResponse[TaskStatusResponse]:
    """Update task status definition."""
    status_service = get_task_status_service(db)

    update_dict = status_data.model_dump(exclude_unset=True)
    updated_status = status_service.update_status(
        status_id=status_id,
        tenant_id=current_user.tenant_id,
        update_data=update_dict,
    )

    if not updated_status:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="STATUS_NOT_FOUND_OR_SYSTEM",
            message=f"Status with ID {status_id} not found or is a system status",
        )

    return StandardResponse(
        data=TaskStatusResponse.model_validate(updated_status),
        message="Status definition updated successfully",
    )


@router.delete(
    "/status-definitions/{status_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Delete task status definition",
    description="Delete a task status definition. Cannot delete system statuses or statuses in use. Requires tasks.manage permission.",
)
async def delete_status_definition(
    status_id: Annotated[UUID, Path(..., description="Status ID")],
    current_user: Annotated[User, Depends(require_permission("tasks.manage"))],
    db: Annotated[Session, Depends(get_db)],
) -> None:
    """Delete task status definition."""
    status_service = get_task_status_service(db)

    deleted = status_service.delete_status(
        status_id=status_id,
        tenant_id=current_user.tenant_id,
    )

    if not deleted:
        raise APIException(
            status_code=status.HTTP_400_BAD_REQUEST,
            code="STATUS_DELETE_ERROR",
            message="Cannot delete status: it may be a system status or in use by tasks",
        )


@router.post(
    "/status-definitions/reorder",
    response_model=StandardListResponse[TaskStatusResponse],
    status_code=status.HTTP_200_OK,
    summary="Reorder task status definitions",
    description="Reorder task status definitions. Requires tasks.manage permission.",
)
async def reorder_status_definitions(
    status_orders: dict[str, int],
    current_user: Annotated[User, Depends(require_permission("tasks.manage"))],
    db: Annotated[Session, Depends(get_db)],
) -> StandardListResponse[TaskStatusResponse]:
    """Reorder task status definitions."""
    status_service = get_task_status_service(db)

    # Convertir string keys a UUID
    status_orders_uuid = {UUID(k): v for k, v in status_orders.items()}

    statuses = status_service.reorder_statuses(
        tenant_id=current_user.tenant_id,
        status_orders=status_orders_uuid,
    )

    return StandardListResponse(
        data=[TaskStatusResponse.model_validate(s) for s in statuses],
        meta={
            "total": len(statuses),
            "page": 1,
            "page_size": len(statuses) if len(statuses) > 0 else 20,
            "total_pages": 1,
        },
        message="Status definitions reordered successfully",
    )


# Task Files Endpoints (Sprint 3 - Fase 2)

@router.post(
    "/{task_id}/files",
    response_model=StandardResponse[dict],
    status_code=status.HTTP_201_CREATED,
    summary="Attach file to task",
    description="Attach an existing file to a task. Requires tasks.manage permission.",
)
async def attach_file_to_task(
    task_id: Annotated[UUID, Path(..., description="Task ID")],
    current_user: Annotated[User, Depends(require_permission("tasks.manage"))],
    db: Annotated[Session, Depends(get_db)],
    file_id: UUID = Query(..., description="File ID from files module"),
    file_name: str = Query(..., description="File name"),
    file_size: int = Query(..., description="File size in bytes"),
    file_type: str = Query(..., description="File MIME type"),
    file_url: str = Query(..., description="File URL"),
) -> StandardResponse[dict]:
    """Attach file to task."""
    logger.info("Attaching file to task: task_id=%s, user_id=%s, file_id=%s",
                task_id, current_user.id, file_id)

    # Validar parÃ¡metros requeridos
    if not file_id or not file_name or not file_size or not file_type or not file_url:
        logger.error("Missing required parameters for file attachment")
        raise APIException(
            status_code=status.HTTP_400_BAD_REQUEST,
            code="MISSING_PARAMETERS",
            message="File ID, name, size, type, and URL are required",
        )

    file_service = get_task_file_service(db)

    try:
        attachment = file_service.attach_file(
            task_id=task_id,
            tenant_id=current_user.tenant_id,
            user_id=current_user.id,
            file_id=file_id,
            file_name=file_name,
            file_size=file_size,
            file_type=file_type,
            file_url=file_url,
        )

        logger.info("File attached successfully: task_id=%s, file_id=%s", task_id, file_id)

        return StandardResponse(
            data=attachment,
            message="File attached to task successfully",
        )
    except ValueError as e:
        logger.error("Failed to attach file: %s", str(e))
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="TASK_NOT_FOUND",
            message=str(e),
        )


@router.delete(
    "/{task_id}/files/{file_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Detach file from task",
    description="Remove a file attachment from a task. Requires tasks.manage permission.",
)
async def detach_file_from_task(
    task_id: Annotated[UUID, Path(..., description="Task ID")],
    file_id: Annotated[UUID, Path(..., description="File ID")],
    current_user: Annotated[User, Depends(require_permission("tasks.manage"))],
    db: Annotated[Session, Depends(get_db)],
) -> None:
    """Detach file from task."""
    logger.info("Detaching file from task: task_id=%s, file_id=%s, user_id=%s",
                task_id, file_id, current_user.id)

    file_service = get_task_file_service(db)

    success = file_service.detach_file(
        task_id=task_id,
        tenant_id=current_user.tenant_id,
        user_id=current_user.id,
        file_id=file_id,
    )

    logger.info("File detach result: task_id=%s, file_id=%s, success=%s",
                task_id, file_id, success)

    if not success:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="FILE_NOT_FOUND",
            message=f"File {file_id} not found in task {task_id}",
        )


@router.get(
    "/{task_id}/files",
    response_model=StandardListResponse[dict],
    status_code=status.HTTP_200_OK,
    summary="List task files",
    description="List all files attached to a task. Requires tasks.view permission.",
)
async def list_task_files(
    task_id: Annotated[UUID, Path(..., description="Task ID")],
    current_user: Annotated[User, Depends(require_permission("tasks.view"))],
    db: Annotated[Session, Depends(get_db)],
) -> StandardListResponse[dict]:
    """List task files."""
    logger.info("Listing files for task: task_id=%s, user_id=%s", task_id, current_user.id)

    file_service = get_task_file_service(db)

    files = file_service.list_files(
        task_id=task_id,
        tenant_id=current_user.tenant_id,
    )

    logger.info("Retrieved %d files for task %s", len(files), task_id)

    return StandardListResponse(
        data=files,
        meta={
            "total": len(files),
            "page": 1,
            "page_size": len(files) if len(files) > 0 else 20,
            "total_pages": 1,
        },
        message="Task files retrieved successfully",
    )


# Task Comments Endpoints (Sprint 4 - Fase 2)


@router.post(
    "/{task_id}/comments",
    response_model=StandardResponse[dict],
    status_code=status.HTTP_201_CREATED,
    summary="Add comment to task",
    description="Add a comment to a task. Supports @mentions. Requires tasks.view permission.",
)
async def add_comment_to_task(
    task_id: Annotated[UUID, Path(..., description="Task ID")],
    current_user: Annotated[User, Depends(require_permission("tasks.view"))],
    db: Annotated[Session, Depends(get_db)],
    comment_data: dict = Body(..., description="Comment data with content and mentions"),
) -> StandardResponse[dict]:
    """Add comment to task."""
    import logging
    logger = logging.getLogger(__name__)
    logger.error(f"[POST COMMENT] Endpoint llamado con task_id={task_id}")
    comment_service = get_task_comment_service(db)

    # Extraer content y mentions del body
    content = comment_data.get("content", "").strip()
    mentions = comment_data.get("mentions", [])

    if not content:
        raise APIException(
            status_code=status.HTTP_422_UNPROCESSABLE_CONTENT,
            code="VALIDATION_ERROR",
            message="Content field is required",
        )

    try:
        comment = comment_service.add_comment(
            task_id=task_id,
            tenant_id=current_user.tenant_id,
            user_id=current_user.id,
            content=content,
            mentions=mentions,
        )

        return StandardResponse(
            data=comment,
            message="Comment added successfully",
        )
    except ValueError as e:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="TASK_NOT_FOUND",
            message=str(e),
        )


@router.put(
    "/{task_id}/comments/{comment_id}",
    response_model=StandardResponse[dict],
    status_code=status.HTTP_200_OK,
    summary="Update comment",
    description="Update a comment. Only the author can update. Requires tasks.view permission.",
)
async def update_task_comment(
    task_id: Annotated[UUID, Path(..., description="Task ID")],
    comment_id: Annotated[str, Path(..., description="Comment ID")],
    current_user: Annotated[User, Depends(require_permission("tasks.view"))],
    db: Annotated[Session, Depends(get_db)],
    comment_data: dict = Body(..., description="Comment update data"),
) -> StandardResponse[dict]:
    """Update task comment."""
    comment_service = get_task_comment_service(db)

    content = comment_data.get("content")
    if not content:
        raise APIException(
            status_code=status.HTTP_422_UNPROCESSABLE_CONTENT,
            code="VALIDATION_ERROR",
            message="Content field is required",
        )

    comment = comment_service.update_comment(
        task_id=task_id,
        tenant_id=current_user.tenant_id,
        user_id=current_user.id,
        comment_id=comment_id,
        content=content,
    )

    if not comment:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="COMMENT_NOT_FOUND",
            message=f"Comment {comment_id} not found or you don't have permission to update it",
        )

    return StandardResponse(
        data=comment,
        message="Comment updated successfully",
    )


@router.delete(
    "/{task_id}/comments/{comment_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Delete comment",
    description="Delete a comment. Only the author can delete. Requires tasks.view permission.",
)
async def delete_task_comment(
    task_id: Annotated[UUID, Path(..., description="Task ID")],
    comment_id: Annotated[str, Path(..., description="Comment ID")],
    current_user: Annotated[User, Depends(require_permission("tasks.view"))],
    db: Annotated[Session, Depends(get_db)],
) -> None:
    """Delete task comment."""
    comment_service = get_task_comment_service(db)

    success = comment_service.delete_comment(
        task_id=task_id,
        tenant_id=current_user.tenant_id,
        user_id=current_user.id,
        comment_id=comment_id,
    )

    if not success:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="COMMENT_NOT_FOUND",
            message=f"Comment {comment_id} not found or you don't have permission to delete it",
        )


@router.get(
    "/{task_id}/comments",
    response_model=StandardListResponse[dict],
    status_code=status.HTTP_200_OK,
    summary="List task comments",
    description="List all comments for a task. Requires tasks.view permission.",
)
async def list_task_comments(
    task_id: Annotated[UUID, Path(..., description="Task ID")],
    current_user: Annotated[User, Depends(require_permission("tasks.view"))],
    db: Annotated[Session, Depends(get_db)],
) -> StandardListResponse[dict]:
    """List task comments."""
    logger.info("Listing comments for task: task_id=%s, user_id=%s, tenant_id=%s",
                task_id, current_user.id, current_user.tenant_id)

    try:
        comment_service = get_task_comment_service(db)

        comments = comment_service.list_comments(
            task_id=task_id,
            tenant_id=current_user.tenant_id,
        )

        logger.info("Retrieved %d comments for task %s", len(comments), task_id)

        return StandardListResponse(
            data=comments,
            meta={
                "total": len(comments),
                "page": 1,
                "page_size": len(comments) if len(comments) > 0 else 20,
                "total_pages": 1,
            },
            message="Task comments retrieved successfully",
        )

    except Exception as e:
        logger.error("Error listing comments for task %s: %s", task_id, str(e))
        raise APIException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            code="COMMENTS_ERROR",
            message="Failed to retrieve task comments",
        )


# Task Tags & Search Endpoints (Sprint 5 - Fase 2)


@router.get(
    "/search",
    response_model=StandardListResponse[TaskResponse],
    status_code=status.HTTP_200_OK,
    summary="Advanced task search",
    description="Search tasks with full-text and filters. Requires tasks.view permission.",
)
async def search_tasks(
    current_user: Annotated[User, Depends(require_permission("tasks.view"))],
    db: Annotated[Session, Depends(get_db)],
    q: str = Query("", description="Search query"),
    tag_ids: list[UUID] | None = Query(None, description="Filter by tag IDs"),
    status_filter: str | None = Query(None, alias="status", description="Filter by status"),
    priority: str | None = Query(None, description="Filter by priority"),
    limit: int = Query(50, description="Result limit"),
) -> StandardListResponse[TaskResponse]:
    """Advanced task search."""
    tag_service = get_task_tag_service(db)

    tasks = tag_service.search_tasks(
        tenant_id=current_user.tenant_id,
        query=q,
        tag_ids=tag_ids,
        status=status_filter,
        priority=priority,
        limit=limit,
    )

    return StandardListResponse(
        data=[TaskResponse.model_validate(task) for task in tasks],
        meta={
            "total": len(tasks),
            "page": 1,
            "page_size": len(tasks) if len(tasks) > 0 else 20,
            "total_pages": 1,
        },
        message="Search completed successfully",
    )


@router.get(
    "/tags/popular",
    response_model=StandardListResponse[dict],
    status_code=status.HTTP_200_OK,
    summary="Get popular tags",
    description="Get most used tags. Requires tasks.view permission.",
)
async def get_popular_tags(
    current_user: Annotated[User, Depends(require_permission("tasks.view"))],
    db: Annotated[Session, Depends(get_db)],
    limit: int = Query(20, description="Result limit"),
) -> StandardListResponse[dict]:
    """Get popular tags."""
    tag_service = get_task_tag_service(db)

    tags = tag_service.get_popular_tags(
        tenant_id=current_user.tenant_id,
        limit=limit,
    )

    return StandardListResponse(
        data=tags,
        meta={
            "total": len(tags),
            "page": 1,
            "page_size": len(tags) if len(tags) > 0 else 20,
            "total_pages": 1,
        },
        message="Popular tags retrieved successfully",
    )


@router.get(
    "/tags/suggest",
    response_model=StandardResponse[list[str]],
    status_code=status.HTTP_200_OK,
    summary="Suggest tags",
    description="Get tag suggestions based on search query. Requires tasks.view permission.",
)
async def suggest_tags(
    current_user: Annotated[User, Depends(require_permission("tasks.view"))],
    db: Annotated[Session, Depends(get_db)],
    q: str = Query(..., description="Search query"),
    limit: int = Query(10, description="Result limit"),
) -> StandardResponse[list[str]]:
    """Suggest tags."""
    tag_service = get_task_tag_service(db)

    suggestions = tag_service.suggest_tags(
        tenant_id=current_user.tenant_id,
        query=q,
        limit=limit,
    )

    return StandardResponse(
        data=suggestions,
        message="Tag suggestions retrieved successfully",
    )


# Analytics & Preferences Endpoints (Sprint 5 - Fase 2)


@router.get(
    "/analytics/adoption",
    response_model=StandardResponse[dict],
    status_code=status.HTTP_200_OK,
    summary="Get feature adoption metrics",
    description="Get adoption metrics for task features. Requires tasks.manage permission.",
)
async def get_adoption_metrics(
    current_user: Annotated[User, Depends(require_permission("tasks.manage"))],
    db: Annotated[Session, Depends(get_db)],
) -> StandardResponse[dict]:
    """Get feature adoption metrics."""
    from app.analytics.task_adoption import get_task_adoption_analytics

    analytics = get_task_adoption_analytics(db)
    metrics = analytics.get_feature_adoption(current_user.tenant_id)

    return StandardResponse(
        data=metrics,
        message="Adoption metrics retrieved successfully",
    )


@router.get(
    "/analytics/trends",
    response_model=StandardResponse[dict],
    status_code=status.HTTP_200_OK,
    summary="Get adoption trends",
    description="Get adoption trends over time. Requires tasks.manage permission.",
)
async def get_adoption_trends(
    current_user: Annotated[User, Depends(require_permission("tasks.manage"))],
    db: Annotated[Session, Depends(get_db)],
    days: int = Query(30, description="Days to analyze"),
) -> StandardResponse[dict]:
    """Get adoption trends."""
    from app.analytics.task_adoption import get_task_adoption_analytics

    analytics = get_task_adoption_analytics(db)
    trends = analytics.get_adoption_trends(current_user.tenant_id, days)

    return StandardResponse(
        data=trends,
        message="Adoption trends retrieved successfully",
    )


@router.get(
    "/preferences/calendar",
    response_model=StandardResponse[dict],
    status_code=status.HTTP_200_OK,
    summary="Get user calendar preferences",
    description="Get current user's calendar preferences. Requires tasks.view permission.",
)
async def get_calendar_preferences(
    current_user: Annotated[User, Depends(require_permission("tasks.view"))],
    db: Annotated[Session, Depends(get_db)],
) -> StandardResponse[dict]:
    """Get user calendar preferences."""
    from app.models.user_calendar_preferences import UserCalendarPreferences

    prefs = (
        db.query(UserCalendarPreferences)
        .filter(UserCalendarPreferences.user_id == current_user.id)
        .first()
    )

    if not prefs:
        # Crear preferencias por defecto
        prefs = UserCalendarPreferences(user_id=current_user.id)
        db.add(prefs)
        db.commit()
        db.refresh(prefs)

    return StandardResponse(
        data={
            "id": str(prefs.id),
            "user_id": str(prefs.user_id),
            "auto_sync_enabled": prefs.auto_sync_enabled,
            "default_calendar_provider": prefs.default_calendar_provider,
            "timezone": prefs.timezone,
            "time_format": prefs.time_format,
        },
        message="Calendar preferences retrieved successfully",
    )


@router.put(
    "/preferences/calendar",
    response_model=StandardResponse[dict],
    status_code=status.HTTP_200_OK,
    summary="Update user calendar preferences",
    description="Update current user's calendar preferences. Requires tasks.view permission.",
)
async def update_calendar_preferences(
    preferences: dict,
    current_user: Annotated[User, Depends(require_permission("tasks.view"))],
    db: Annotated[Session, Depends(get_db)],
) -> StandardResponse[dict]:
    """Update user calendar preferences."""
    from app.models.user_calendar_preferences import UserCalendarPreferences

    prefs = (
        db.query(UserCalendarPreferences)
        .filter(UserCalendarPreferences.user_id == current_user.id)
        .first()
    )

    if not prefs:
        prefs = UserCalendarPreferences(user_id=current_user.id)
        db.add(prefs)

    # Actualizar campos
    for key, value in preferences.items():
        if hasattr(prefs, key):
            setattr(prefs, key, value)

    db.commit()
    db.refresh(prefs)

    return StandardResponse(
        data={
            "id": str(prefs.id),
            "user_id": str(prefs.user_id),
            "auto_sync_enabled": prefs.auto_sync_enabled,
            "default_calendar_provider": prefs.default_calendar_provider,
            "timezone": prefs.timezone,
            "time_format": prefs.time_format,
        },
        message="Calendar preferences updated successfully",
    )


@router.get(
    "/{task_id}",
    response_model=StandardResponse[TaskResponse],
    status_code=status.HTTP_200_OK,
    summary="Get task",
    description="Get a specific task by ID. Requires tasks.view permission.",
)
async def get_task(
    task_id: Annotated[UUID, Path(..., description="Task ID")],
    current_user: Annotated[User, Depends(require_permission("tasks.view"))],
    service: Annotated[TaskService, Depends(get_task_service)],
) -> StandardResponse[TaskResponse]:
    """Get a specific task."""
    task = service.get_task(task_id, current_user.tenant_id)
    if not task:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="TASK_NOT_FOUND",
            message=f"Task with ID {task_id} not found",
        )

    return StandardResponse(
        data=TaskResponse.model_validate(task),
        message="Task retrieved successfully",
    )


# Task Dependencies Endpoints


@router.get(
    "/{task_id}/dependencies",
    response_model=StandardResponse[dict],
    status_code=status.HTTP_200_OK,
    summary="List task dependencies",
    description="List all dependencies and dependents for a task. Requires tasks.view permission.",
)
async def list_task_dependencies(
    task_id: Annotated[UUID, Path(..., description="Task ID")],
    current_user: Annotated[User, Depends(require_permission("tasks.view"))],
    db: Annotated[Session, Depends(get_db)],
) -> StandardResponse[dict]:
    """List task dependencies."""
    from app.core.tasks.dependency_service import get_task_dependency_service

    dependency_service = get_task_dependency_service(db)

    # Verify task exists and user has access
    service = get_task_service(db)
    task = service.get_task(task_id, current_user.tenant_id)
    if not task:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="TASK_NOT_FOUND",
            message=f"Task with ID {task_id} not found",
        )

    dependencies = dependency_service.get_dependencies(
        task_id=task_id,
        tenant_id=current_user.tenant_id
    )
    dependents = dependency_service.get_dependents(
        task_id=task_id,
        tenant_id=current_user.tenant_id
    )

    return StandardResponse(
        data={
            "dependencies": [
                {
                    "id": str(dep.id),
                    "task_id": str(dep.task_id),
                    "depends_on_id": str(dep.depends_on_id),
                    "dependency_type": dep.dependency_type,
                    "created_at": dep.created_at.isoformat() if dep.created_at else None,
                }
                for dep in dependencies
            ],
            "dependents": [
                {
                    "id": str(dep.id),
                    "task_id": str(dep.task_id),
                    "depends_on_id": str(dep.depends_on_id),
                    "dependency_type": dep.dependency_type,
                    "created_at": dep.created_at.isoformat() if dep.created_at else None,
                }
                for dep in dependents
            ]
        },
        message="Task dependencies retrieved successfully",
    )


@router.post(
    "/{task_id}/dependencies",
    response_model=StandardResponse[dict],
    status_code=status.HTTP_201_CREATED,
    summary="Add task dependency",
    description="Add a dependency between tasks. Requires tasks.manage permission.",
)
async def add_task_dependency(
    task_id: Annotated[UUID, Path(..., description="Task ID")],
    current_user: Annotated[User, Depends(require_permission("tasks.manage"))],
    db: Annotated[Session, Depends(get_db)],
    dependency_data: dict = Body(..., description="Dependency data"),
) -> StandardResponse[dict]:
    """Add a dependency between tasks."""
    from app.core.tasks.dependency_service import get_task_dependency_service

    dependency_service = get_task_dependency_service(db)

    # Verify task exists and user has access
    service = get_task_service(db)
    task = service.get_task(task_id, current_user.tenant_id)
    if not task:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="TASK_NOT_FOUND",
            message=f"Task with ID {task_id} not found",
        )

    depends_on_id = dependency_data.get("depends_on_id")
    dependency_type = dependency_data.get("dependency_type", "finish_to_start")

    if not depends_on_id:
        raise APIException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            code="VALIDATION_ERROR",
            message="depends_on_id is required",
        )

    try:
        dependency = dependency_service.add_dependency(
            task_id=task_id,
            depends_on_id=UUID(depends_on_id),
            tenant_id=current_user.tenant_id,
            dependency_type=dependency_type
        )

        return StandardResponse(
            data={
                "id": str(dependency.id),
                "task_id": str(dependency.task_id),
                "depends_on_id": str(dependency.depends_on_id),
                "dependency_type": dependency.dependency_type,
                "created_at": dependency.created_at.isoformat() if dependency.created_at else None,
            },
            message="Task dependency added successfully",
        )
    except ValueError as e:
        raise APIException(
            status_code=status.HTTP_400_BAD_REQUEST,
            code="DEPENDENCY_ERROR",
            message=str(e),
        )


@router.delete(
    "/{task_id}/dependencies/{dependency_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Remove task dependency",
    description="Remove a dependency between tasks. Requires tasks.manage permission.",
)
async def remove_task_dependency(
    task_id: Annotated[UUID, Path(..., description="Task ID")],
    dependency_id: Annotated[UUID, Path(..., description="Dependency ID")],
    current_user: Annotated[User, Depends(require_permission("tasks.manage"))],
    db: Annotated[Session, Depends(get_db)],
) -> None:
    """Remove a task dependency."""
    from app.core.tasks.dependency_service import get_task_dependency_service

    dependency_service = get_task_dependency_service(db)

    # Verify task exists and user has access
    service = get_task_service(db)
    task = service.get_task(task_id, current_user.tenant_id)
    if not task:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="TASK_NOT_FOUND",
            message=f"Task with ID {task_id} not found",
        )

    success = dependency_service.remove_dependency(
        dependency_id=dependency_id,
        tenant_id=current_user.tenant_id
    )

    if not success:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="DEPENDENCY_NOT_FOUND",
            message=f"Dependency with ID {dependency_id} not found",
        )
