"""Activities router for timeline management."""

from typing import Annotated
from uuid import UUID

from fastapi import APIRouter, Depends, Path, Query, status
from sqlalchemy.orm import Session

from app.core.activities.service import ActivityService
from app.core.auth.dependencies import require_permission
from app.core.db.deps import get_db
from app.core.exceptions import APIException
from app.models.user import User
from app.schemas.activity import ActivityCreate, ActivityResponse, ActivityUpdate
from app.schemas.common import StandardListResponse, StandardResponse

router = APIRouter()


def get_activity_service(
    db: Annotated[Session, Depends(get_db)],
) -> ActivityService:
    """Dependency to get ActivityService."""
    return ActivityService(db)


@router.post(
    "",
    response_model=StandardResponse[ActivityResponse],
    status_code=status.HTTP_201_CREATED,
    summary="Create activity",
    description="Create a new activity. Requires activities.manage permission.",
)
async def create_activity(
    activity_data: ActivityCreate,
    current_user: Annotated[User, Depends(require_permission("activities.manage"))],
    service: Annotated[ActivityService, Depends(get_activity_service)],
) -> StandardResponse[ActivityResponse]:
    """Create a new activity."""
    activity = service.create_activity(
        entity_type=activity_data.entity_type,
        entity_id=activity_data.entity_id,
        activity_type=activity_data.activity_type,
        title=activity_data.title,
        tenant_id=current_user.tenant_id,
        user_id=current_user.id,
        description=activity_data.description,
        metadata=activity_data.metadata,
    )

    return StandardResponse(
        data=ActivityResponse.model_validate(activity),
        message="Activity created successfully",
    )


@router.get(
    "",
    response_model=StandardListResponse[ActivityResponse],
    status_code=status.HTTP_200_OK,
    summary="List activities",
    description="List activities with optional filters. Requires activities.view permission.",
)
async def list_activities(
    current_user: Annotated[User, Depends(require_permission("activities.view"))],
    service: Annotated[ActivityService, Depends(get_activity_service)],
    page: int = Query(default=1, ge=1, description="Page number"),
    page_size: int = Query(default=20, ge=1, le=100, description="Page size"),
    activity_type: str | None = Query(None, description="Filter by activity type"),
    entity_type: str | None = Query(None, description="Filter by entity type"),
    entity_id: UUID | None = Query(None, description="Filter by entity ID"),
    search: str | None = Query(None, description="Search in title and description"),
) -> StandardListResponse[ActivityResponse]:
    """List activities."""
    skip = (page - 1) * page_size

    if search:
        activities = service.search_activities(
            tenant_id=current_user.tenant_id,
            query=search,
            entity_type=entity_type,
            activity_type=activity_type,
            skip=skip,
            limit=page_size,
        )
        total = len(activities)  # TODO: Add count method to repository
    elif entity_type and entity_id:
        activities = service.get_activities(
            entity_type=entity_type,
            entity_id=entity_id,
            tenant_id=current_user.tenant_id,
            activity_type=activity_type,
            skip=skip,
            limit=page_size,
        )
        total = len(activities)  # TODO: Add count method to repository
    else:
        activities = service.repository.get_all(
            current_user.tenant_id, activity_type, skip, page_size
        )
        total = len(activities)  # TODO: Add count method to repository

    total_pages = (total + page_size - 1) // page_size if total > 0 else 0

    return StandardListResponse(
        data=[ActivityResponse.model_validate(a) for a in activities],
        total=total,
        page=page,
        page_size=page_size,
        total_pages=total_pages,
        message="Activities retrieved successfully",
    )


@router.get(
    "/{activity_id}",
    response_model=StandardResponse[ActivityResponse],
    status_code=status.HTTP_200_OK,
    summary="Get activity",
    description="Get a specific activity by ID. Requires activities.view permission.",
)
async def get_activity(
    current_user: Annotated[User, Depends(require_permission("activities.view"))],
    service: Annotated[ActivityService, Depends(get_activity_service)],
    activity_id: UUID = Path(..., description="Activity ID"),
) -> StandardResponse[ActivityResponse]:
    """Get a specific activity."""
    activity = service.repository.get_by_id(activity_id, current_user.tenant_id)
    if not activity:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="ACTIVITY_NOT_FOUND",
            message=f"Activity with ID {activity_id} not found",
        )

    return StandardResponse(
        data=ActivityResponse.model_validate(activity),
        message="Activity retrieved successfully",
    )


@router.put(
    "/{activity_id}",
    response_model=StandardResponse[ActivityResponse],
    status_code=status.HTTP_200_OK,
    summary="Update activity",
    description="Update an activity. Requires activities.manage permission.",
)
async def update_activity(
    activity_data: ActivityUpdate,
    current_user: Annotated[User, Depends(require_permission("activities.manage"))],
    service: Annotated[ActivityService, Depends(get_activity_service)],
    activity_id: UUID = Path(..., description="Activity ID"),
) -> StandardResponse[ActivityResponse]:
    """Update an activity."""
    activity = service.update_activity(
        activity_id=activity_id,
        tenant_id=current_user.tenant_id,
        user_id=current_user.id,
        title=activity_data.title,
        description=activity_data.description,
        metadata=activity_data.metadata,
    )

    if not activity:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="ACTIVITY_NOT_FOUND",
            message=f"Activity with ID {activity_id} not found",
        )

    return StandardResponse(
        data=ActivityResponse.model_validate(activity),
        message="Activity updated successfully",
    )


@router.delete(
    "/{activity_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Delete activity",
    description="Delete an activity. Requires activities.manage permission.",
)
async def delete_activity(
    current_user: Annotated[User, Depends(require_permission("activities.manage"))],
    service: Annotated[ActivityService, Depends(get_activity_service)],
    activity_id: UUID = Path(..., description="Activity ID"),
) -> None:
    """Delete an activity."""
    deleted = service.delete_activity(
        activity_id, current_user.tenant_id, current_user.id
    )
    if not deleted:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="ACTIVITY_NOT_FOUND",
            message=f"Activity with ID {activity_id} not found",
        )


@router.get(
    "/entity/{entity_type}/{entity_id}",
    response_model=StandardListResponse[ActivityResponse],
    status_code=status.HTTP_200_OK,
    summary="Get entity timeline",
    description="Get timeline of activities for a specific entity. Requires activities.view permission.",
)
async def get_entity_timeline(
    current_user: Annotated[User, Depends(require_permission("activities.view"))],
    service: Annotated[ActivityService, Depends(get_activity_service)],
    entity_type: str = Path(..., description="Entity type"),
    entity_id: UUID = Path(..., description="Entity ID"),
    page: int = Query(default=1, ge=1, description="Page number"),
    page_size: int = Query(default=20, ge=1, le=100, description="Page size"),
    activity_type: str | None = Query(None, description="Filter by activity type"),
) -> StandardListResponse[ActivityResponse]:
    """Get timeline of activities for a specific entity."""
    skip = (page - 1) * page_size
    activities = service.get_activities(
        entity_type=entity_type,
        entity_id=entity_id,
        tenant_id=current_user.tenant_id,
        activity_type=activity_type,
        skip=skip,
        limit=page_size,
    )

    total = len(activities)  # TODO: Add count method to repository
    total_pages = (total + page_size - 1) // page_size if total > 0 else 0

    return StandardListResponse(
        data=[ActivityResponse.model_validate(a) for a in activities],
        meta={
            "total": total,
            "page": page,
            "page_size": page_size,
            "total_pages": total_pages,
        },
        message="Entity timeline retrieved successfully",
    )


"""Approvals router for approval workflow management."""

from datetime import datetime
from typing import Annotated
from uuid import UUID

from fastapi import APIRouter, Depends, Path, Query, status
from sqlalchemy.orm import Session

from app.core.approvals.service import ApprovalService
from app.core.auth.dependencies import require_permission
from app.core.db.deps import get_db
from app.core.exceptions import APIException
from app.core.tasks.service import TaskService
from app.models.user import User
from app.schemas.approval import (
    ApprovalActionCreate,
    ApprovalActionResponse,
    ApprovalDelegationCreate,
    ApprovalDelegationResponse,
    ApprovalFlowCreate,
    ApprovalFlowResponse,
    ApprovalFlowUpdate,
    ApprovalRequestCreate,
    ApprovalRequestResponse,
    ApprovalStepCreate,
    ApprovalStepResponse,
)
from app.schemas.common import StandardListResponse, StandardResponse

router = APIRouter()


def get_approval_service(
    db: Annotated[Session, Depends(get_db)],
) -> ApprovalService:
    """Dependency to get ApprovalService."""
    return ApprovalService(db)


# Approval Flow endpoints
@router.post(
    "/flows",
    response_model=StandardResponse[ApprovalFlowResponse],
    status_code=status.HTTP_201_CREATED,
    summary="Create approval flow",
    description="Create a new approval flow. Requires approvals.manage permission.",
)
async def create_approval_flow(
    flow_data: ApprovalFlowCreate,
    current_user: Annotated[User, Depends(require_permission("approvals.manage"))],
    service: Annotated[ApprovalService, Depends(get_approval_service)],
) -> StandardResponse[ApprovalFlowResponse]:
    """Create a new approval flow."""
    flow = service.create_approval_flow(
        flow_data=flow_data.model_dump(exclude_none=True),
        tenant_id=current_user.tenant_id,
        user_id=current_user.id,
    )

    return StandardResponse(
        data=ApprovalFlowResponse.model_validate(flow),
        message="Approval flow created successfully",
    )


@router.get(
    "/flows",
    response_model=StandardListResponse[ApprovalFlowResponse],
    status_code=status.HTTP_200_OK,
    summary="List approval flows",
    description="List approval flows. Requires approvals.view permission.",
)
async def list_approval_flows(
    current_user: Annotated[User, Depends(require_permission("approvals.view"))],
    service: Annotated[ApprovalService, Depends(get_approval_service)],
    module: str | None = Query(None, description="Filter by module"),
    is_active: bool | None = Query(None, description="Filter by active status"),
    page: int = Query(default=1, ge=1, description="Page number"),
    page_size: int = Query(default=20, ge=1, le=100, description="Page size"),
) -> StandardListResponse[ApprovalFlowResponse]:
    """List approval flows."""
    skip = (page - 1) * page_size
    flows = service.get_approval_flows(
        tenant_id=current_user.tenant_id,
        module=module,
        is_active=is_active,
        skip=skip,
        limit=page_size,
    )

    total = len(flows)
    total_pages = (total + page_size - 1) // page_size if total > 0 else 0

    return StandardListResponse(
        data=[ApprovalFlowResponse.model_validate(f) for f in flows],
        total=total,
        page=page,
        page_size=page_size,
        total_pages=total_pages,
        message="Approval flows retrieved successfully",
    )


@router.get(
    "/flows/{flow_id}",
    response_model=StandardResponse[ApprovalFlowResponse],
    status_code=status.HTTP_200_OK,
    summary="Get approval flow",
    description="Get a specific approval flow by ID. Requires approvals.view permission.",
)
async def get_approval_flow(
    flow_id: Annotated[UUID, Path(..., description="Approval flow ID")],
    current_user: Annotated[User, Depends(require_permission("approvals.view"))],
    service: Annotated[ApprovalService, Depends(get_approval_service)],
) -> StandardResponse[ApprovalFlowResponse]:
    """Get a specific approval flow."""
    flow = service.get_approval_flow(flow_id, current_user.tenant_id)
    if not flow:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="APPROVAL_FLOW_NOT_FOUND",
            message=f"Approval flow with ID {flow_id} not found",
        )

    return StandardResponse(
        data=ApprovalFlowResponse.model_validate(flow),
        message="Approval flow retrieved successfully",
    )


@router.post(
    "/flows/{flow_id}/steps",
    response_model=StandardResponse[ApprovalStepResponse],
    status_code=status.HTTP_201_CREATED,
    summary="Add approval step",
    description="Add a step to an approval flow. Requires approvals.manage permission.",
)
async def add_approval_step(
    flow_id: Annotated[UUID, Path(..., description="Approval flow ID")],
    step_data: ApprovalStepCreate,
    current_user: Annotated[User, Depends(require_permission("approvals.manage"))],
    service: Annotated[ApprovalService, Depends(get_approval_service)],
) -> StandardResponse[ApprovalStepResponse]:
    """Add a step to an approval flow."""
    step = service.add_approval_step(
        flow_id=flow_id,
        tenant_id=current_user.tenant_id,
        step_data=step_data.model_dump(exclude_none=True),
    )

    return StandardResponse(
        data=ApprovalStepResponse.model_validate(step),
        message="Approval step added successfully",
    )


# Approval Request endpoints
@router.post(
    "/requests",
    response_model=StandardResponse[ApprovalRequestResponse],
    status_code=status.HTTP_201_CREATED,
    summary="Create approval request",
    description="Create a new approval request. Requires approvals.manage permission.",
)
async def create_approval_request(
    request_data: ApprovalRequestCreate,
    current_user: Annotated[User, Depends(require_permission("approvals.manage"))],
    service: Annotated[ApprovalService, Depends(get_approval_service)],
) -> StandardResponse[ApprovalRequestResponse]:
    """Create a new approval request."""
    request = service.create_approval_request(
        request_data=request_data.model_dump(exclude_none=True),
        tenant_id=current_user.tenant_id,
        user_id=current_user.id,
    )

    return StandardResponse(
        data=ApprovalRequestResponse.model_validate(request),
        message="Approval request created successfully",
    )


@router.get(
    "/requests",
    response_model=StandardListResponse[ApprovalRequestResponse],
    status_code=status.HTTP_200_OK,
    summary="List approval requests",
    description="List approval requests. Requires approvals.view permission.",
)
async def list_approval_requests(
    current_user: Annotated[User, Depends(require_permission("approvals.view"))],
    service: Annotated[ApprovalService, Depends(get_approval_service)],
    flow_id: UUID | None = Query(None, description="Filter by flow ID"),
    entity_type: str | None = Query(None, description="Filter by entity type"),
    entity_id: UUID | None = Query(None, description="Filter by entity ID"),
    status: str | None = Query(None, description="Filter by status"),
    page: int = Query(default=1, ge=1, description="Page number"),
    page_size: int = Query(default=20, ge=1, le=100, description="Page size"),
) -> StandardListResponse[ApprovalRequestResponse]:
    """List approval requests."""
    skip = (page - 1) * page_size
    requests = service.get_approval_requests(
        tenant_id=current_user.tenant_id,
        flow_id=flow_id,
        entity_type=entity_type,
        entity_id=entity_id,
        status=status,
        requested_by=current_user.id,
        skip=skip,
        limit=page_size,
    )

    total = len(requests)
    total_pages = (total + page_size - 1) // page_size if total > 0 else 0

    return StandardListResponse(
        data=[ApprovalRequestResponse.model_validate(r) for r in requests],
        total=total,
        page=page,
        page_size=page_size,
        total_pages=total_pages,
        message="Approval requests retrieved successfully",
    )


@router.get(
    "/requests/{request_id}",
    response_model=StandardResponse[ApprovalRequestResponse],
    status_code=status.HTTP_200_OK,
    summary="Get approval request",
    description="Get a specific approval request by ID. Requires approvals.view permission.",
)
async def get_approval_request(
    request_id: Annotated[UUID, Path(..., description="Approval request ID")],
    current_user: Annotated[User, Depends(require_permission("approvals.view"))],
    service: Annotated[ApprovalService, Depends(get_approval_service)],
) -> StandardResponse[ApprovalRequestResponse]:
    """Get a specific approval request."""
    request = service.get_approval_request(request_id, current_user.tenant_id)
    if not request:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="APPROVAL_REQUEST_NOT_FOUND",
            message=f"Approval request with ID {request_id} not found",
        )

    return StandardResponse(
        data=ApprovalRequestResponse.model_validate(request),
        message="Approval request retrieved successfully",
    )


@router.post(
    "/requests/{request_id}/approve",
    response_model=StandardResponse[ApprovalRequestResponse],
    status_code=status.HTTP_200_OK,
    summary="Approve request",
    description="Approve an approval request. Requires approvals.approve permission.",
)
async def approve_request(
    request_id: Annotated[UUID, Path(..., description="Approval request ID")],
    current_user: Annotated[User, Depends(require_permission("approvals.approve"))],
    service: Annotated[ApprovalService, Depends(get_approval_service)],
    comment: Annotated[str | None, Query(description="Optional comment")] = None,
) -> StandardResponse[ApprovalRequestResponse]:
    """Approve an approval request."""
    try:
        request = service.approve_request(
            request_id=request_id,
            tenant_id=current_user.tenant_id,
            user_id=current_user.id,
            comment=comment,
        )

        return StandardResponse(
            data=ApprovalRequestResponse.model_validate(request),
            message="Request approved successfully",
        )
    except ValueError as e:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="APPROVAL_REQUEST_NOT_FOUND",
            message=str(e),
        )


@router.post(
    "/requests/{request_id}/reject",
    response_model=StandardResponse[ApprovalRequestResponse],
    status_code=status.HTTP_200_OK,
    summary="Reject request",
    description="Reject an approval request. Requires approvals.approve permission.",
)
async def reject_request(
    request_id: Annotated[UUID, Path(..., description="Approval request ID")],
    current_user: Annotated[User, Depends(require_permission("approvals.approve"))],
    service: Annotated[ApprovalService, Depends(get_approval_service)],
    comment: Annotated[str | None, Query(description="Optional comment")] = None,
) -> StandardResponse[ApprovalRequestResponse]:
    """Reject an approval request."""
    try:
        request = service.reject_request(
            request_id=request_id,
            tenant_id=current_user.tenant_id,
            user_id=current_user.id,
            comment=comment,
        )

        return StandardResponse(
            data=ApprovalRequestResponse.model_validate(request),
            message="Request rejected successfully",
        )
    except ValueError as e:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="APPROVAL_REQUEST_NOT_FOUND",
            message=str(e),
        )


@router.get(
    "/requests/{request_id}/actions",
    response_model=StandardListResponse[ApprovalActionResponse],
    status_code=status.HTTP_200_OK,
    summary="Get approval actions",
    description="Get approval actions for a request. Requires approvals.view permission.",
)
async def get_approval_actions(
    request_id: Annotated[UUID, Path(..., description="Approval request ID")],
    current_user: Annotated[User, Depends(require_permission("approvals.view"))],
    service: Annotated[ApprovalService, Depends(get_approval_service)],
) -> StandardListResponse[ApprovalActionResponse]:
    """Get approval actions for a request."""
    actions = service.get_approval_actions(request_id, current_user.tenant_id)

    return StandardListResponse(
        data=[ApprovalActionResponse.model_validate(a) for a in actions],
        total=len(actions),
        page=1,
        page_size=len(actions),
        total_pages=1,
        message="Approval actions retrieved successfully",
    )


# Approval Delegation endpoints
@router.post(
    "/requests/{request_id}/delegate",
    response_model=StandardResponse[ApprovalDelegationResponse],
    status_code=status.HTTP_201_CREATED,
    summary="Delegate approval",
    description="Delegate an approval to another user. Requires approvals.delegate permission.",
)
async def delegate_approval(
    request_id: Annotated[UUID, Path(..., description="Approval request ID")],
    to_user_id: Annotated[UUID, Query(..., description="User ID to delegate to")],
    current_user: Annotated[User, Depends(require_permission("approvals.delegate"))],
    service: Annotated[ApprovalService, Depends(get_approval_service)],
    reason: str | None = Query(default=None, description="Delegation reason"),
    expires_at: datetime | None = Query(default=None, description="Delegation expiration"),
) -> StandardResponse[ApprovalDelegationResponse]:
    """Delegate an approval to another user."""
    delegation = service.delegate_approval(
        request_id=request_id,
        tenant_id=current_user.tenant_id,
        from_user_id=current_user.id,
        to_user_id=to_user_id,
        reason=reason,
        expires_at=expires_at,
    )

    return StandardResponse(
        data=ApprovalDelegationResponse.model_validate(delegation),
        message="Approval delegated successfully",
    )



"""Authentication router for login, refresh, logout, and user info."""

from typing import Annotated
from uuid import UUID

from datetime import datetime

from fastapi import APIRouter, Depends, Query, Request, status
from sqlalchemy.orm import Session

from app.core.auth.dependencies import get_current_user
from app.core.exceptions import (
    raise_bad_request,
    raise_conflict,
    raise_forbidden,
    raise_not_found,
    raise_unauthorized,
)
from app.core.auth.rate_limit import (
    check_login_rate_limit,
    create_rate_limit_exception,
    record_login_attempt,
)
from app.core.db.deps import get_db
from app.core.logging import (
    create_audit_log_entry,
    get_client_info,
    log_auth_failure,
    log_auth_success,
    log_logout,
    log_permission_change,
    log_rate_limit_exceeded,
)
from app.core.auth.dependencies import require_permission
from app.models.user import User
from app.schemas.audit import AuditLogListResponse, AuditLogResponse
from app.schemas.auth import (
    AccessTokenResponse,
    LoginRequest,
    RefreshTokenRequest,
    RoleAssignRequest,
    RoleListResponse,
    RoleResponse,
    TokenResponse,
    UserMeResponse,
)
from app.schemas.common import StandardResponse
from app.schemas.permission import (
    DelegatedPermissionListResponse,
    DelegatedPermissionResponse,
    PermissionGrantRequest,
    RevokePermissionResponse,
)
from app.services.audit_service import AuditService
from app.services.auth_service import AuthService
from app.services.permission_service import PermissionService

router = APIRouter()


@router.post(
    "/login",
    response_model=StandardResponse[TokenResponse],
    status_code=status.HTTP_200_OK,
)
async def login(
    login_data: LoginRequest,
    request: Request,
    db: Annotated[Session, Depends(get_db)],
) -> StandardResponse[TokenResponse]:
    """
    Authenticate user and return access and refresh tokens.

    Security:
    - Rate limiting: 5 attempts per minute per IP
    - Does not reveal if user exists (generic error message)
    - Returns both access and refresh tokens on success

    Args:
        login_data: Login credentials (email, password).
        request: FastAPI request object (for IP address).
        db: Database session.

    Returns:
        TokenResponse with access_token and refresh_token.

    Raises:
        HTTPException: If credentials are invalid or rate limit exceeded.
    """
    # Rate limiting check
    client_ip = request.client.host if request.client else "unknown"
    if not check_login_rate_limit(client_ip, max_attempts=5, window_minutes=1):
        record_login_attempt(client_ip)
        log_rate_limit_exceeded(client_ip)
        raise create_rate_limit_exception()

    # Authenticate user
    auth_service = AuthService(db)
    user = auth_service.authenticate_user(login_data.email, login_data.password)

    # Record attempt (success or failure)
    record_login_attempt(client_ip)

    # Generic error message (does not reveal if user exists)
    if not user:
        log_auth_failure(login_data.email, "invalid_credentials", client_ip)
        raise_unauthorized(
            code="AUTH_INVALID_CREDENTIALS",
            message="Invalid credentials",
        )

    # Log successful login (auth_service already logs, but we add IP here)
    log_auth_success(str(user.id), login_data.email, str(user.tenant_id), client_ip)

    # Create tokens
    access_token = auth_service.create_access_token_for_user(user)
    refresh_token = auth_service.create_refresh_token_for_user(user)

    return StandardResponse(
        data=TokenResponse(
            access_token=access_token,
            token_type="bearer",
            refresh_token=refresh_token,
        ),
        message="Login successful",
    )


@router.post(
    "/refresh",
    response_model=StandardResponse[AccessTokenResponse],
    status_code=status.HTTP_200_OK,
)
async def refresh_token(
    refresh_data: RefreshTokenRequest,
    db: Annotated[Session, Depends(get_db)],
) -> StandardResponse[AccessTokenResponse]:
    """
    Refresh an access token using a valid refresh token.

    Args:
        refresh_data: Refresh token request.
        db: Database session.

    Returns:
        AccessTokenResponse with new access_token.

    Raises:
        HTTPException: If refresh token is invalid, expired, or revoked.
    """
    auth_service = AuthService(db)
    access_token = auth_service.refresh_access_token(refresh_data.refresh_token)

    if not access_token:
        raise_unauthorized(
            code="AUTH_REFRESH_TOKEN_INVALID",
            message="Invalid or expired refresh token",
        )

    return StandardResponse(
        data=AccessTokenResponse(access_token=access_token, token_type="bearer"),
        message="Token refreshed successfully",
    )


@router.post("/logout", status_code=status.HTTP_200_OK)
async def logout(
    refresh_data: RefreshTokenRequest,
    request: Request,
    current_user: Annotated[User, Depends(get_current_user)],
    db: Annotated[Session, Depends(get_db)],
) -> dict[str, str]:
    """
    Logout user by revoking refresh token.

    Args:
        refresh_data: Refresh token to revoke.
        request: FastAPI request object (for IP address).
        current_user: Current authenticated user.
        db: Database session.

    Returns:
        Success message.

    Raises:
        HTTPException: If refresh token is invalid.
    """
    auth_service = AuthService(db)
    success = auth_service.revoke_refresh_token(
        refresh_data.refresh_token, current_user.id
    )

    if not success:
        raise_unauthorized(
            code="AUTH_REFRESH_TOKEN_INVALID",
            message="Invalid refresh token",
        )

    # Log logout
    client_ip = request.client.host if request.client else "unknown"
    log_logout(str(current_user.id), client_ip)

    return {"message": "Logged out successfully"}


@router.get("/me", response_model=UserMeResponse, status_code=status.HTTP_200_OK)
async def get_current_user_info(
    current_user: Annotated[User, Depends(get_current_user)],
    db: Annotated[Session, Depends(get_db)],
) -> UserMeResponse:
    """
    Get current authenticated user information with roles and permissions.

    Args:
        current_user: Current authenticated user.
        db: Database session.

    Returns:
        UserMeResponse with user info, roles, and permissions.
    """
    auth_service = AuthService(db)
    roles = auth_service.get_user_roles(current_user.id)
    permissions = auth_service.get_user_permissions(current_user.id)

    return StandardResponse(
        data=UserMeResponse(
            id=current_user.id,
            email=current_user.email,
            full_name=current_user.full_name,
            tenant_id=current_user.tenant_id,
            roles=roles,
            permissions=permissions,
        ),
        message="User information retrieved successfully",
    )


@router.post(
    "/modules/{module}/permissions",
    response_model=DelegatedPermissionResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Grant a delegated permission",
    description="Grant a delegated permission to a user. Requires {module}.manage_users permission.",
    responses={
        201: {"description": "Permission granted successfully"},
        400: {
            "description": "Invalid permission or validation error",
            "content": {
                "application/json": {
                    "example": {
                        "error": {
                            "code": "INVALID_PERMISSION",
                            "message": "Cannot delegate permission '*.manage_users'",
                            "details": None,
                        }
                    }
                }
            },
        },
        403: {
            "description": "Insufficient permissions",
            "content": {
                "application/json": {
                    "example": {
                        "error": {
                            "code": "PERMISSION_DENIED",
                            "message": "User does not have permission 'inventory.manage_users' to grant permissions",
                            "details": None,
                        }
                    }
                }
            },
        },
        409: {
            "description": "Permission already exists",
            "content": {
                "application/json": {
                    "example": {
                        "error": {
                            "code": "PERMISSION_ALREADY_EXISTS",
                            "message": "Permission 'inventory.edit' already granted to this user by you",
                            "details": None,
                        }
                    }
                }
            },
        },
    },
)
async def grant_permission(
    module: str,
    permission_data: PermissionGrantRequest,
    current_user: Annotated[User, Depends(get_current_user)],
    db: Annotated[Session, Depends(get_db)],
) -> StandardResponse[DelegatedPermissionResponse]:
    """
    Grant a delegated permission to a user.

    Requires: {module}.manage_users

    Args:
        module: Module name (e.g., "inventory", "products").
        permission_data: Permission grant request (user_id, permission, expires_at).
        current_user: Current authenticated user (must have {module}.manage_users).
        db: Database session.

    Returns:
        DelegatedPermissionResponse with granted permission details.

    Raises:
        HTTPException: If user lacks permission or validation fails.
    """
    permission_service = PermissionService(db)

    # Verificar que el permiso pertenece al módulo
    if not permission_data.permission.startswith(f"{module}."):
        raise_bad_request(
            code="INVALID_PERMISSION",
            message=f"Permission '{permission_data.permission}' does not belong to module '{module}'",
        )

    delegated_permission = permission_service.grant_permission(
        user_id=permission_data.user_id,
        module=module,
        permission=permission_data.permission,
        expires_at=permission_data.expires_at,
        granted_by=current_user.id,
    )

    return StandardResponse(
        data=DelegatedPermissionResponse(
            id=delegated_permission.id,
            user_id=delegated_permission.user_id,
            granted_by=delegated_permission.granted_by,
            module=delegated_permission.module,
            permission=delegated_permission.permission,
            expires_at=delegated_permission.expires_at,
            created_at=delegated_permission.created_at,
            revoked_at=delegated_permission.revoked_at,
            is_active=delegated_permission.is_active,
        ),
        message="Permission granted successfully",
    )


@router.delete(
    "/modules/{module}/permissions/{permission_id}",
    response_model=StandardResponse[RevokePermissionResponse],
    status_code=status.HTTP_200_OK,
    summary="Revoke a delegated permission",
    description="Revoke a delegated permission. Requires being the granter OR having auth.manage_users.",
    responses={
        200: {"description": "Permission revoked successfully"},
        400: {
            "description": "Invalid request",
            "content": {
                "application/json": {
                    "example": {
                        "error": {
                            "code": "PERMISSION_ALREADY_REVOKED",
                            "message": "Permission is already revoked",
                            "details": None,
                        }
                    }
                }
            },
        },
        403: {
            "description": "Insufficient permissions",
            "content": {
                "application/json": {
                    "example": {
                        "error": {
                            "code": "PERMISSION_DENIED",
                            "message": "You can only revoke permissions you granted",
                            "details": None,
                        }
                    }
                }
            },
        },
        404: {
            "description": "Permission not found",
            "content": {
                "application/json": {
                    "example": {
                        "error": {
                            "code": "PERMISSION_NOT_FOUND",
                            "message": "Permission not found",
                            "details": None,
                        }
                    }
                }
            },
        },
    },
)
async def revoke_permission(
    module: str,
    permission_id: UUID,
    current_user: Annotated[User, Depends(get_current_user)],
    db: Annotated[Session, Depends(get_db)],
) -> RevokePermissionResponse:
    """
    Revoke a delegated permission.

    Requires: Be the granter OR have auth.manage_users

    Args:
        module: Module name (for validation).
        permission_id: Permission UUID to revoke.
        current_user: Current authenticated user.
        db: Database session.

    Returns:
        RevokePermissionResponse with success message.

    Raises:
        HTTPException: If permission not found or user lacks permission.
    """
    permission_service = PermissionService(db)

    # Verificar que el permiso pertenece al módulo
    from app.repositories.permission_repository import PermissionRepository

    repo = PermissionRepository(db)
    permission = repo.get_delegated_permission_by_id(permission_id)
    if permission and permission.module != module:
        raise_bad_request(
            code="INVALID_MODULE",
            message=f"Permission does not belong to module '{module}'",
        )

    permission_service.revoke_permission(permission_id, current_user.id)

    return RevokePermissionResponse(
        message="Permission revoked successfully",
        revoked_count=1,
    )


@router.delete(
    "/users/{user_id}/permissions",
    response_model=StandardResponse[RevokePermissionResponse],
    status_code=status.HTTP_200_OK,
    summary="Revoke all delegated permissions of a user",
    description="Revoke ALL delegated permissions of a user. Requires auth.manage_users or owner/admin role.",
    responses={
        200: {"description": "Permissions revoked successfully"},
        403: {
            "description": "Insufficient permissions",
            "content": {
                "application/json": {
                    "example": {
                        "error": {
                            "code": "PERMISSION_DENIED",
                            "message": "Only administrators or owners can revoke all permissions of a user",
                            "details": None,
                        }
                    }
                }
            },
        },
    },
)
async def revoke_all_user_permissions(
    user_id: UUID,
    current_user: Annotated[User, Depends(require_permission("auth.manage_users"))],
    db: Annotated[Session, Depends(get_db)],
) -> RevokePermissionResponse:
    """
    Revoke ALL delegated permissions of a user.

    Requires: auth.manage_users or owner/admin role

    Args:
        user_id: User UUID whose permissions will be revoked.
        current_user: Current authenticated user (must be admin/owner).
        db: Database session.

    Returns:
        RevokePermissionResponse with number of permissions revoked.

    Raises:
        HTTPException: If user lacks permission.
    """
    permission_service = PermissionService(db)
    revoked_count = permission_service.revoke_all_user_permissions(
        user_id, current_user.id
    )

    return StandardResponse(
        data=RevokePermissionResponse(
            message=f"Revoked {revoked_count} permission(s) successfully",
            revoked_count=revoked_count,
        ),
        message="Permissions revoked successfully",
    )


@router.delete(
    "/users/{user_id}/permissions/{permission_id}",
    response_model=StandardResponse[RevokePermissionResponse],
    status_code=status.HTTP_200_OK,
    summary="Revoke a specific delegated permission (admin override)",
    description="Revoke a specific delegated permission. Admin override - can revoke any permission. Requires auth.manage_users or owner/admin role.",
    responses={
        200: {"description": "Permission revoked successfully"},
        400: {
            "description": "Invalid request",
            "content": {
                "application/json": {
                    "example": {
                        "error": {
                            "code": "INVALID_USER",
                            "message": "Permission does not belong to this user",
                            "details": None,
                        }
                    }
                }
            },
        },
        403: {
            "description": "Insufficient permissions",
            "content": {
                "application/json": {
                    "example": {
                        "error": {
                            "code": "AUTH_INSUFFICIENT_PERMISSIONS",
                            "message": "Insufficient permissions",
                            "details": {"required_permission": "auth.manage_users"},
                        }
                    }
                }
            },
        },
        404: {
            "description": "Permission not found",
            "content": {
                "application/json": {
                    "example": {
                        "error": {
                            "code": "PERMISSION_NOT_FOUND",
                            "message": "Permission not found",
                            "details": None,
                        }
                    }
                }
            },
        },
    },
)
async def revoke_user_permission(
    user_id: UUID,
    permission_id: UUID,
    current_user: Annotated[User, Depends(require_permission("auth.manage_users"))],
    db: Annotated[Session, Depends(get_db)],
) -> RevokePermissionResponse:
    """
    Revoke a specific delegated permission (admin override).

    Requires: auth.manage_users or owner/admin role

    Args:
        user_id: User UUID (for validation).
        permission_id: Permission UUID to revoke.
        current_user: Current authenticated user (must be admin/owner).
        db: Database session.

    Returns:
        RevokePermissionResponse with success message.

    Raises:
        HTTPException: If permission not found or user lacks permission.
    """
    from app.repositories.permission_repository import PermissionRepository

    # Verificar que el permiso pertenece al usuario
    repo = PermissionRepository(db)
    permission = repo.get_delegated_permission_by_id(permission_id)
    if not permission:
        raise_not_found("Permission", str(permission_id))

    if permission.user_id != user_id:
        raise_bad_request(
            code="INVALID_USER",
            message="Permission does not belong to this user",
        )

    permission_service = PermissionService(db)
    permission_service.revoke_permission(permission_id, current_user.id)

    return StandardResponse(
        data=RevokePermissionResponse(
            message="Permission revoked successfully",
            revoked_count=1,
        ),
        message="Permission revoked successfully",
    )


@router.get(
    "/modules/{module}/permissions/{user_id}",
    response_model=DelegatedPermissionListResponse,
    status_code=status.HTTP_200_OK,
    summary="List delegated permissions for a user in a module",
    description="List all delegated permissions (active and revoked) for a user in a specific module. Requires authentication.",
    responses={
        200: {"description": "List of permissions retrieved successfully"},
    },
)
async def get_user_module_permissions(
    module: str,
    user_id: UUID,
    current_user: Annotated[User, Depends(get_current_user)],
    db: Annotated[Session, Depends(get_db)],
) -> DelegatedPermissionListResponse:
    """
    List delegated permissions for a user in a module.

    Requires: Authentication

    Args:
        module: Module name.
        user_id: User UUID.
        current_user: Current authenticated user.
        db: Database session.

    Returns:
        DelegatedPermissionListResponse with list of permissions.
    """
    from app.repositories.permission_repository import PermissionRepository

    repo = PermissionRepository(db)
    permissions = repo.get_user_module_permissions(user_id, module)

    permission_responses = [
        DelegatedPermissionResponse(
            id=perm.id,
            user_id=perm.user_id,
            granted_by=perm.granted_by,
            module=perm.module,
            permission=perm.permission,
            expires_at=perm.expires_at,
            created_at=perm.created_at,
            revoked_at=perm.revoked_at,
            is_active=perm.is_active,
        )
        for perm in permissions
    ]

    return DelegatedPermissionListResponse(
        permissions=permission_responses,
        total=len(permission_responses),
    )


@router.get(
    "/roles",
    response_model=dict,
    status_code=status.HTTP_200_OK,
    summary="List available global roles",
    description="List all available global roles with their permissions. Requires authentication.",
    responses={
        200: {"description": "List of roles retrieved successfully"},
    },
)
async def list_roles(
    current_user: Annotated[User, Depends(get_current_user)],
) -> dict:
    """
    List all available global roles.

    Requires: Authentication

    Args:
        current_user: Current authenticated user.

    Returns:
        Dictionary with available roles and their permissions.
    """
    from app.core.auth.permissions import ROLE_PERMISSIONS

    roles_data = [
        {
            "role": role,
            "permissions": list(permissions),
        }
        for role, permissions in ROLE_PERMISSIONS.items()
    ]

    return {
        "data": roles_data,
        "meta": {"total": len(roles_data)},
    }


@router.get(
    "/roles/{user_id}",
    response_model=RoleListResponse,
    status_code=status.HTTP_200_OK,
    summary="List user roles",
    description="List all global roles assigned to a user. Requires auth.manage_users permission.",
    responses={
        200: {"description": "List of user roles retrieved successfully"},
        403: {
            "description": "Insufficient permissions",
            "content": {
                "application/json": {
                    "example": {
                        "error": {
                            "code": "AUTH_INSUFFICIENT_PERMISSIONS",
                            "message": "Insufficient permissions",
                            "details": {"required_permission": "auth.manage_users"},
                        }
                    }
                }
            },
        },
        404: {
            "description": "User not found",
            "content": {
                "application/json": {
                    "example": {
                        "error": {
                            "code": "USER_NOT_FOUND",
                            "message": "User not found",
                            "details": None,
                        }
                    }
                }
            },
        },
    },
)
async def get_user_roles(
    user_id: UUID,
    current_user: Annotated[User, Depends(require_permission("auth.manage_users"))],
    db: Annotated[Session, Depends(get_db)],
) -> RoleListResponse:
    """
    List all global roles assigned to a user.

    Requires: auth.manage_users

    Args:
        user_id: User UUID.
        current_user: Current authenticated user (must have auth.manage_users).
        db: Database session.

    Returns:
        RoleListResponse with list of roles.

    Raises:
        HTTPException: If user not found or lacks permission.
    """
    from app.models.user_role import UserRole
    from app.repositories.user_repository import UserRepository

    # Verify user exists and belongs to same tenant
    user_repo = UserRepository(db)
    user = user_repo.get_by_id(user_id)
    if not user:
        raise_not_found("User", str(user_id))

    if user.tenant_id != current_user.tenant_id:
        raise_forbidden(
            code="AUTH_TENANT_MISMATCH",
            message="Cannot access user from different tenant",
        )

    # Get user roles
    roles = db.query(UserRole).filter(UserRole.user_id == user_id).all()

    role_responses = [
        RoleResponse(
            role=role.role,
            granted_by=role.granted_by,
            created_at=role.created_at,
        )
        for role in roles
    ]

    return RoleListResponse(roles=role_responses, total=len(role_responses))


@router.post(
    "/roles/{user_id}",
    response_model=RoleResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Assign global role to user",
    description="Assign a global role to a user. Requires auth.manage_roles permission.",
    responses={
        201: {"description": "Role assigned successfully"},
        400: {
            "description": "Invalid request or role already assigned",
            "content": {
                "application/json": {
                    "example": {
                        "error": {
                            "code": "ROLE_ALREADY_ASSIGNED",
                            "message": "Role 'admin' is already assigned to this user",
                            "details": None,
                        }
                    }
                }
            },
        },
        403: {
            "description": "Insufficient permissions",
            "content": {
                "application/json": {
                    "example": {
                        "error": {
                            "code": "AUTH_INSUFFICIENT_PERMISSIONS",
                            "message": "Insufficient permissions",
                            "details": {"required_permission": "auth.manage_roles"},
                        }
                    }
                }
            },
        },
        404: {
            "description": "User not found",
            "content": {
                "application/json": {
                    "example": {
                        "error": {
                            "code": "USER_NOT_FOUND",
                            "message": "User not found",
                            "details": None,
                        }
                    }
                }
            },
        },
    },
)
async def assign_role(
    user_id: UUID,
    role_data: RoleAssignRequest,
    request: Request,
    current_user: Annotated[User, Depends(require_permission("auth.manage_roles"))],
    db: Annotated[Session, Depends(get_db)],
) -> RoleResponse:
    """
    Assign a global role to a user.

    Requires: auth.manage_roles

    Args:
        user_id: User UUID.
        role_data: Role assignment request.
        current_user: Current authenticated user (must have auth.manage_roles).
        db: Database session.

    Returns:
        RoleResponse with assigned role details.

    Raises:
        HTTPException: If user not found, role already assigned, or validation fails.
    """
    from app.models.user_role import UserRole
    from app.repositories.user_repository import UserRepository

    # Verify user exists and belongs to same tenant
    user_repo = UserRepository(db)
    user = user_repo.get_by_id(user_id)
    if not user:
        raise_not_found("User", str(user_id))

    if user.tenant_id != current_user.tenant_id:
        raise_forbidden(
            code="AUTH_TENANT_MISMATCH",
            message="Cannot access user from different tenant",
        )

    # Check if role already assigned
    existing_role = (
        db.query(UserRole)
        .filter(UserRole.user_id == user_id, UserRole.role == role_data.role)
        .first()
    )
    if existing_role:
        from app.core.exceptions import raise_conflict
        raise_conflict(
            code="ROLE_ALREADY_ASSIGNED",
            message=f"Role '{role_data.role}' is already assigned to this user",
        )

    # Create role assignment
    user_role = UserRole(
        user_id=user_id,
        role=role_data.role,
        granted_by=current_user.id,
    )
    db.add(user_role)
    db.commit()
    db.refresh(user_role)

    # Get client info for audit log
    ip_address, user_agent = get_client_info(request)

    # Log to console
    log_permission_change(
        user_id=str(current_user.id),
        action="assign_global_role",
        target_user_id=str(user_id),
        details={"role": role_data.role, "role_id": str(user_role.id)},
    )

    # Create audit log entry
    create_audit_log_entry(
        db=db,
        user_id=current_user.id,
        tenant_id=current_user.tenant_id,
        action="assign_global_role",
        resource_type="role",
        resource_id=user_role.id,
        details={"role": role_data.role, "target_user_id": str(user_id)},
        ip_address=ip_address,
        user_agent=user_agent,
    )

    return RoleResponse(
        role=user_role.role,
        granted_by=user_role.granted_by,
        created_at=user_role.created_at,
    )


@router.delete(
    "/roles/{user_id}/{role}",
    response_model=dict,
    status_code=status.HTTP_200_OK,
    summary="Remove global role from user",
    description="Remove a global role from a user. Requires auth.manage_roles permission.",
    responses={
        200: {"description": "Role removed successfully"},
        403: {
            "description": "Insufficient permissions",
            "content": {
                "application/json": {
                    "example": {
                        "error": {
                            "code": "AUTH_INSUFFICIENT_PERMISSIONS",
                            "message": "Insufficient permissions",
                            "details": {"required_permission": "auth.manage_roles"},
                        }
                    }
                }
            },
        },
        404: {
            "description": "User or role not found",
            "content": {
                "application/json": {
                    "example": {
                        "error": {
                            "code": "ROLE_NOT_FOUND",
                            "message": "Role 'admin' is not assigned to this user",
                            "details": None,
                        }
                    }
                }
            },
        },
    },
)
async def remove_role(
    user_id: UUID,
    role: str,
    request: Request,
    current_user: Annotated[User, Depends(require_permission("auth.manage_roles"))],
    db: Annotated[Session, Depends(get_db)],
) -> dict:
    """
    Remove a global role from a user.

    Requires: auth.manage_roles

    Args:
        user_id: User UUID.
        role: Role name to remove.
        current_user: Current authenticated user (must have auth.manage_roles).
        db: Database session.

    Returns:
        Dictionary with success message.

    Raises:
        HTTPException: If user not found, role not assigned, or lacks permission.
    """
    from app.core.auth.permissions import ROLE_PERMISSIONS
    from app.models.user_role import UserRole
    from app.repositories.user_repository import UserRepository

    # Validate role
    if role not in ROLE_PERMISSIONS:
        raise_bad_request(
            code="INVALID_ROLE",
            message=f"Invalid role '{role}'. Valid roles: {', '.join(ROLE_PERMISSIONS.keys())}",
        )

    # Verify user exists and belongs to same tenant
    user_repo = UserRepository(db)
    user = user_repo.get_by_id(user_id)
    if not user:
        raise_not_found("User", str(user_id))

    if user.tenant_id != current_user.tenant_id:
        raise_forbidden(
            code="AUTH_TENANT_MISMATCH",
            message="Cannot access user from different tenant",
        )

    # Find and remove role
    user_role = (
        db.query(UserRole)
        .filter(UserRole.user_id == user_id, UserRole.role == role)
        .first()
    )
    if not user_role:
        raise_not_found("Role", f"{role} for user {user_id}")

    # Store role info before deletion for audit log
    original_granted_by = user_role.granted_by

    db.delete(user_role)
    db.commit()

    # Get client info for audit log
    ip_address, user_agent = get_client_info(request)

    # Log to console
    log_permission_change(
        user_id=str(current_user.id),
        action="remove_global_role",
        target_user_id=str(user_id),
        details={
            "role": role,
            "original_granted_by": str(original_granted_by) if original_granted_by else None,
        },
    )

    # Create audit log entry
    create_audit_log_entry(
        db=db,
        user_id=current_user.id,
        tenant_id=current_user.tenant_id,
        action="remove_global_role",
        resource_type="role",
        resource_id=None,  # Role already deleted
        details={
            "role": role,
            "target_user_id": str(user_id),
            "original_granted_by": str(original_granted_by) if original_granted_by else None,
        },
        ip_address=ip_address,
        user_agent=user_agent,
    )

    return {"message": f"Role '{role}' removed successfully"}


@router.get(
    "/audit-logs",
    response_model=AuditLogListResponse,
    status_code=status.HTTP_200_OK,
    summary="Get audit logs",
    description="Get audit logs with filters and pagination. Requires auth.view_audit permission.",
    responses={
        200: {"description": "Audit logs retrieved successfully"},
        403: {
            "description": "Insufficient permissions",
            "content": {
                "application/json": {
                    "example": {
                        "error": {
                            "code": "AUTH_INSUFFICIENT_PERMISSIONS",
                            "message": "Insufficient permissions",
                            "details": {"required_permission": "auth.view_audit"},
                        }
                    }
                }
            },
        },
    },
)
async def get_audit_logs(
    current_user: Annotated[User, Depends(require_permission("auth.view_audit"))],
    db: Annotated[Session, Depends(get_db)],
    user_id: UUID | None = Query(None, description="Filter by user ID"),
    action: str | None = Query(None, description="Filter by action type"),
    resource_type: str | None = Query(None, description="Filter by resource type"),
    date_from: datetime | None = Query(None, description="Filter by start date (ISO format)"),
    date_to: datetime | None = Query(None, description="Filter by end date (ISO format)"),
    page: int = Query(default=1, ge=1, description="Page number"),
    page_size: int = Query(default=20, ge=1, le=100, description="Page size"),
) -> AuditLogListResponse:
    """
    Get audit logs with filters and pagination.

    Requires: auth.view_audit

    Args:
        current_user: Current authenticated user (must have auth.view_audit).
        db: Database session.
        user_id: Filter by user ID (optional).
        action: Filter by action type (optional).
        resource_type: Filter by resource type (optional).
        date_from: Filter by start date (optional).
        date_to: Filter by end date (optional).
        page: Page number (default: 1).
        page_size: Page size (default: 20, max: 100).

    Returns:
        AuditLogListResponse with list of audit logs and pagination metadata.

    Raises:
        HTTPException: If user lacks permission.
    """
    audit_service = AuditService(db)
    skip = (page - 1) * page_size

    logs, total = audit_service.get_audit_logs(
        tenant_id=current_user.tenant_id,
        user_id=user_id,
        action=action,
        resource_type=resource_type,
        date_from=date_from,
        date_to=date_to,
        skip=skip,
        limit=page_size,
    )

    return AuditLogListResponse(
        data=logs,
        meta={
            "total": total,
            "page": page,
            "page_size": page_size,
            "total_pages": (total + page_size - 1) // page_size if total > 0 else 0,
        },
    )


"""Automation router for rule management."""

from typing import Annotated, Any
from uuid import UUID

from fastapi import APIRouter, Depends, Query, status
from sqlalchemy.orm import Session

from app.core.auth.dependencies import require_permission
from app.core.automation.engine import AutomationEngine
from app.core.automation.service import AutomationService
from app.core.db.deps import get_db
from app.core.exceptions import APIException
from app.core.pubsub import EventPublisher, get_event_publisher
from app.core.pubsub.models import Event, EventMetadata
from app.models.user import User
from app.schemas.automation import (
    ActionSchema,
    AutomationExecutionResponse,
    ConditionSchema,
    RuleCreate,
    RuleResponse,
    RuleUpdate,
    TriggerSchema,
)
from app.schemas.common import StandardListResponse, StandardResponse

router = APIRouter()


def get_automation_service(db: Annotated[Session, Depends(get_db)]) -> AutomationService:
    """Dependency to get AutomationService."""
    return AutomationService(db)


def get_automation_engine(db: Annotated[Session, Depends(get_db)]) -> AutomationEngine:
    """Dependency to get AutomationEngine."""
    return AutomationEngine(db)


@router.post(
    "/rules",
    response_model=StandardResponse[RuleResponse],
    status_code=status.HTTP_201_CREATED,
    summary="Create automation rule",
    description="Create a new automation rule. Requires automation.manage permission.",
)
async def create_rule(
    rule_data: RuleCreate,
    current_user: Annotated[User, Depends(require_permission("automation.manage"))],
    service: Annotated[AutomationService, Depends(get_automation_service)],
) -> StandardResponse[RuleResponse]:
    """Create a new automation rule."""
    # Convert Pydantic models to dicts for storage
    trigger_dict = rule_data.trigger.model_dump()
    conditions_dict = (
        [c.model_dump() for c in rule_data.conditions] if rule_data.conditions else None
    )
    actions_dict = [a.model_dump() for a in rule_data.actions]

    rule = service.create_rule(
        tenant_id=current_user.tenant_id,
        name=rule_data.name,
        description=rule_data.description,
        trigger=trigger_dict,
        conditions=conditions_dict,
        actions=actions_dict,
        enabled=rule_data.enabled,
    )

    return StandardResponse(
        data=RuleResponse.model_validate(rule),
        message="Rule created successfully",
    )


@router.get(
    "/rules",
    response_model=StandardListResponse[RuleResponse],
    status_code=status.HTTP_200_OK,
    summary="List automation rules",
    description="List all automation rules for the current tenant. Requires automation.view permission.",
)
async def list_rules(
    current_user: Annotated[User, Depends(require_permission("automation.view"))],
    service: Annotated[AutomationService, Depends(get_automation_service)],
    page: int = Query(default=1, ge=1, description="Page number"),
    page_size: int = Query(default=20, ge=1, le=100, description="Page size"),
    enabled_only: bool = Query(default=False, description="Only return enabled rules"),
) -> StandardListResponse[RuleResponse]:
    """List all automation rules."""
    skip = (page - 1) * page_size
    rules = service.get_all_rules(
        tenant_id=current_user.tenant_id, enabled_only=enabled_only, skip=skip, limit=page_size
    )

    total = len(rules)  # TODO: Add count method to repository
    total_pages = (total + page_size - 1) // page_size if total > 0 else 0

    return StandardListResponse(
        data=[RuleResponse.model_validate(rule) for rule in rules],
        total=total,
        page=page,
        page_size=page_size,
        total_pages=total_pages,
        message="Rules retrieved successfully",
    )


@router.get(
    "/rules/{rule_id}",
    response_model=StandardResponse[RuleResponse],
    status_code=status.HTTP_200_OK,
    summary="Get automation rule",
    description="Get a specific automation rule by ID. Requires automation.view permission.",
)
async def get_rule(
    rule_id: UUID,
    current_user: Annotated[User, Depends(require_permission("automation.view"))],
    service: Annotated[AutomationService, Depends(get_automation_service)],
) -> StandardResponse[RuleResponse]:
    """Get a specific automation rule."""
    rule = service.get_rule(rule_id, current_user.tenant_id)
    if not rule:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="AUTOMATION_RULE_NOT_FOUND",
            message=f"Rule with ID {rule_id} not found",
        )

    return StandardResponse(
        data=RuleResponse.model_validate(rule),
        message="Rule retrieved successfully",
    )


@router.put(
    "/rules/{rule_id}",
    response_model=StandardResponse[RuleResponse],
    status_code=status.HTTP_200_OK,
    summary="Update automation rule",
    description="Update an automation rule. Requires automation.manage permission.",
)
async def update_rule(
    rule_id: UUID,
    rule_data: RuleUpdate,
    current_user: Annotated[User, Depends(require_permission("automation.manage"))],
    service: Annotated[AutomationService, Depends(get_automation_service)],
) -> StandardResponse[RuleResponse]:
    """Update an automation rule."""
    # Convert Pydantic models to dicts if provided
    trigger_dict = rule_data.trigger.model_dump() if rule_data.trigger else None
    conditions_dict = (
        [c.model_dump() for c in rule_data.conditions] if rule_data.conditions else None
    )
    actions_dict = [a.model_dump() for a in rule_data.actions] if rule_data.actions else None

    rule = service.update_rule(
        rule_id=rule_id,
        tenant_id=current_user.tenant_id,
        name=rule_data.name,
        description=rule_data.description,
        trigger=trigger_dict,
        conditions=conditions_dict,
        actions=actions_dict,
        enabled=rule_data.enabled,
    )

    if not rule:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="AUTOMATION_RULE_NOT_FOUND",
            message=f"Rule with ID {rule_id} not found",
        )

    return StandardResponse(
        data=RuleResponse.model_validate(rule),
        message="Rule updated successfully",
    )


@router.delete(
    "/rules/{rule_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Delete automation rule",
    description="Delete an automation rule. Requires automation.manage permission.",
)
async def delete_rule(
    rule_id: UUID,
    current_user: Annotated[User, Depends(require_permission("automation.manage"))],
    service: Annotated[AutomationService, Depends(get_automation_service)],
) -> None:
    """Delete an automation rule."""
    deleted = service.delete_rule(rule_id, current_user.tenant_id)
    if not deleted:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="AUTOMATION_RULE_NOT_FOUND",
            message=f"Rule with ID {rule_id} not found",
        )


@router.post(
    "/rules/{rule_id}/execute",
    response_model=StandardResponse[dict[str, Any]],
    status_code=status.HTTP_200_OK,
    summary="Execute automation rule manually",
    description="Execute an automation rule manually with a test event. Requires automation.manage permission.",
)
async def execute_rule(
    rule_id: UUID,
    current_user: Annotated[User, Depends(require_permission("automation.manage"))],
    service: Annotated[AutomationService, Depends(get_automation_service)],
    engine: Annotated[AutomationEngine, Depends(get_automation_engine)],
    event_type: str = Query(..., description="Event type to simulate"),
    entity_type: str = Query(..., description="Entity type"),
    entity_id: UUID = Query(..., description="Entity ID"),
) -> StandardResponse[dict[str, Any]]:
    """Execute an automation rule manually."""
    rule = service.get_rule(rule_id, current_user.tenant_id)
    if not rule:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="AUTOMATION_RULE_NOT_FOUND",
            message=f"Rule with ID {rule_id} not found",
        )

    # Create a test event
    test_event = Event(
        event_type=event_type,
        entity_type=entity_type,
        entity_id=entity_id,
        tenant_id=current_user.tenant_id,
        user_id=current_user.id,
        metadata=EventMetadata(
            source="automation_service",
            version="1.0",
            additional_data={"manual_execution": True},
        ),
    )

    execution = await engine.execute_rule(rule, test_event)

    return StandardResponse(
        data={
            "execution_id": str(execution.id),
            "status": execution.status,
            "result": execution.result,
        },
        message="Rule executed successfully",
    )


@router.get(
    "/rules/{rule_id}/executions",
    response_model=StandardListResponse[AutomationExecutionResponse],
    status_code=status.HTTP_200_OK,
    summary="Get rule execution history",
    description="Get execution history for a rule. Requires automation.view permission.",
)
async def get_rule_executions(
    rule_id: UUID,
    current_user: Annotated[User, Depends(require_permission("automation.view"))],
    service: Annotated[AutomationService, Depends(get_automation_service)],
    page: int = Query(default=1, ge=1, description="Page number"),
    page_size: int = Query(default=20, ge=1, le=100, description="Page size"),
) -> StandardListResponse[AutomationExecutionResponse]:
    """Get execution history for a rule."""
    # Verify rule exists and belongs to tenant
    rule = service.get_rule(rule_id, current_user.tenant_id)
    if not rule:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="AUTOMATION_RULE_NOT_FOUND",
            message=f"Rule with ID {rule_id} not found",
        )

    skip = (page - 1) * page_size
    executions = service.get_executions(rule_id, skip=skip, limit=page_size)

    total = len(executions)  # TODO: Add count method to repository
    total_pages = (total + page_size - 1) // page_size if total > 0 else 0

    return StandardListResponse(
        data=[AutomationExecutionResponse.model_validate(ex) for ex in executions],
        total=total,
        page=page,
        page_size=page_size,
        total_pages=total_pages,
        message="Executions retrieved successfully",
    )







"""Calendar router for calendar and event management."""

from datetime import datetime
from typing import Annotated
from uuid import UUID

from fastapi import APIRouter, Depends, Path, Query, status
from sqlalchemy.orm import Session

from app.core.auth.dependencies import require_permission
from app.core.calendar.service import CalendarService, ReminderService
from app.core.db.deps import get_db
from app.core.exceptions import APIException
from app.core.notifications.service import NotificationService
from app.models.user import User
from app.schemas.calendar import (
    CalendarCreate,
    CalendarEventCreate,
    CalendarEventResponse,
    CalendarEventUpdate,
    CalendarResponse,
    CalendarUpdate,
    EventAttendeeCreate,
    EventAttendeeResponse,
    EventAttendeeUpdate,
    EventReminderCreate,
    EventReminderResponse,
)
from app.schemas.common import StandardListResponse, StandardResponse

router = APIRouter()


def get_calendar_service(
    db: Annotated[Session, Depends(get_db)],
) -> CalendarService:
    """Dependency to get CalendarService."""
    return CalendarService(db)


def get_reminder_service(
    db: Annotated[Session, Depends(get_db)],
) -> ReminderService:
    """Dependency to get ReminderService."""
    return ReminderService(db)


# Calendar endpoints
@router.post(
    "/calendars",
    response_model=StandardResponse[CalendarResponse],
    status_code=status.HTTP_201_CREATED,
    summary="Create calendar",
    description="Create a new calendar. Requires calendar.manage permission.",
)
async def create_calendar(
    calendar_data: CalendarCreate,
    current_user: Annotated[User, Depends(require_permission("calendar.manage"))],
    service: Annotated[CalendarService, Depends(get_calendar_service)],
) -> StandardResponse[CalendarResponse]:
    """Create a new calendar."""
    calendar = service.create_calendar(
        calendar_data=calendar_data.model_dump(exclude_none=True),
        tenant_id=current_user.tenant_id,
        owner_id=current_user.id,
    )

    return StandardResponse(
        data=CalendarResponse.model_validate(calendar),
        message="Calendar created successfully",
    )


@router.get(
    "/calendars",
    response_model=StandardListResponse[CalendarResponse],
    status_code=status.HTTP_200_OK,
    summary="List calendars",
    description="List calendars for the current user. Requires calendar.view permission.",
)
async def list_calendars(
    current_user: Annotated[User, Depends(require_permission("calendar.view"))],
    service: Annotated[CalendarService, Depends(get_calendar_service)],
    calendar_type: str | None = Query(None, description="Filter by calendar type"),
) -> StandardListResponse[CalendarResponse]:
    """List calendars."""
    calendars = service.get_user_calendars(
        user_id=current_user.id,
        tenant_id=current_user.tenant_id,
        calendar_type=calendar_type,
    )

    return StandardListResponse(
        data=[CalendarResponse.model_validate(c) for c in calendars],
        total=len(calendars),
        page=1,
        page_size=len(calendars),
        total_pages=1,
        message="Calendars retrieved successfully",
    )


@router.get(
    "/calendars/{calendar_id}",
    response_model=StandardResponse[CalendarResponse],
    status_code=status.HTTP_200_OK,
    summary="Get calendar",
    description="Get a specific calendar by ID. Requires calendar.view permission.",
)
async def get_calendar(
    calendar_id: Annotated[UUID, Path(..., description="Calendar ID")],
    current_user: Annotated[User, Depends(require_permission("calendar.view"))],
    service: Annotated[CalendarService, Depends(get_calendar_service)],
) -> StandardResponse[CalendarResponse]:
    """Get a specific calendar."""
    calendar = service.get_calendar(calendar_id, current_user.tenant_id)
    if not calendar:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="CALENDAR_NOT_FOUND",
            message=f"Calendar with ID {calendar_id} not found",
        )

    return StandardResponse(
        data=CalendarResponse.model_validate(calendar),
        message="Calendar retrieved successfully",
    )


@router.put(
    "/calendars/{calendar_id}",
    response_model=StandardResponse[CalendarResponse],
    status_code=status.HTTP_200_OK,
    summary="Update calendar",
    description="Update a calendar. Requires calendar.manage permission.",
)
async def update_calendar(
    calendar_id: Annotated[UUID, Path(..., description="Calendar ID")],
    calendar_data: CalendarUpdate,
    current_user: Annotated[User, Depends(require_permission("calendar.manage"))],
    service: Annotated[CalendarService, Depends(get_calendar_service)],
) -> StandardResponse[CalendarResponse]:
    """Update a calendar."""
    calendar = service.update_calendar(
        calendar_id=calendar_id,
        tenant_id=current_user.tenant_id,
        calendar_data=calendar_data.model_dump(exclude_none=True),
    )

    if not calendar:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="CALENDAR_NOT_FOUND",
            message=f"Calendar with ID {calendar_id} not found",
        )

    return StandardResponse(
        data=CalendarResponse.model_validate(calendar),
        message="Calendar updated successfully",
    )


@router.delete(
    "/calendars/{calendar_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Delete calendar",
    description="Delete a calendar. Requires calendar.manage permission.",
)
async def delete_calendar(
    calendar_id: Annotated[UUID, Path(..., description="Calendar ID")],
    current_user: Annotated[User, Depends(require_permission("calendar.manage"))],
    service: Annotated[CalendarService, Depends(get_calendar_service)],
) -> None:
    """Delete a calendar."""
    success = service.delete_calendar(calendar_id, current_user.tenant_id)
    if not success:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="CALENDAR_NOT_FOUND",
            message=f"Calendar with ID {calendar_id} not found",
        )


# Event endpoints
@router.post(
    "/events",
    response_model=StandardResponse[CalendarEventResponse],
    status_code=status.HTTP_201_CREATED,
    summary="Create event",
    description="Create a new calendar event. Requires calendar.events.manage permission.",
)
async def create_event(
    event_data: CalendarEventCreate,
    current_user: Annotated[User, Depends(require_permission("calendar.events.manage"))],
    service: Annotated[CalendarService, Depends(get_calendar_service)],
) -> StandardResponse[CalendarEventResponse]:
    """Create a new calendar event."""
    event = service.create_event(
        event_data=event_data.model_dump(exclude_none=True),
        tenant_id=current_user.tenant_id,
        organizer_id=current_user.id,
    )

    return StandardResponse(
        data=CalendarEventResponse.model_validate(event),
        message="Event created successfully",
    )


@router.get(
    "/events",
    response_model=StandardListResponse[CalendarEventResponse],
    status_code=status.HTTP_200_OK,
    summary="List events",
    description="List calendar events. Requires calendar.events.view permission.",
)
async def list_events(
    current_user: Annotated[User, Depends(require_permission("calendar.events.view"))],
    service: Annotated[CalendarService, Depends(get_calendar_service)],
    calendar_id: UUID | None = Query(None, description="Filter by calendar ID"),
    start_date: datetime | None = Query(None, description="Filter by start date"),
    end_date: datetime | None = Query(None, description="Filter by end date"),
    status: str | None = Query(None, description="Filter by status"),
    page: int = Query(default=1, ge=1, description="Page number"),
    page_size: int = Query(default=20, ge=1, le=100, description="Page size"),
) -> StandardListResponse[CalendarEventResponse]:
    """List calendar events."""
    skip = (page - 1) * page_size

    if calendar_id:
        events = service.get_events_by_calendar(
            calendar_id=calendar_id,
            tenant_id=current_user.tenant_id,
            start_date=start_date,
            end_date=end_date,
            status=status,
            skip=skip,
            limit=page_size,
        )
    else:
        events = service.get_user_events(
            user_id=current_user.id,
            tenant_id=current_user.tenant_id,
            start_date=start_date,
            end_date=end_date,
            skip=skip,
            limit=page_size,
        )

    total = len(events)  # TODO: Add count method to repository
    total_pages = (total + page_size - 1) // page_size if total > 0 else 0

    return StandardListResponse(
        data=[CalendarEventResponse.model_validate(e) for e in events],
        total=total,
        page=page,
        page_size=page_size,
        total_pages=total_pages,
        message="Events retrieved successfully",
    )


@router.get(
    "/events/{event_id}",
    response_model=StandardResponse[CalendarEventResponse],
    status_code=status.HTTP_200_OK,
    summary="Get event",
    description="Get a specific event by ID. Requires calendar.events.view permission.",
)
async def get_event(
    event_id: Annotated[UUID, Path(..., description="Event ID")],
    current_user: Annotated[User, Depends(require_permission("calendar.events.view"))],
    service: Annotated[CalendarService, Depends(get_calendar_service)],
) -> StandardResponse[CalendarEventResponse]:
    """Get a specific event."""
    event = service.get_event(event_id, current_user.tenant_id)
    if not event:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="EVENT_NOT_FOUND",
            message=f"Event with ID {event_id} not found",
        )

    return StandardResponse(
        data=CalendarEventResponse.model_validate(event),
        message="Event retrieved successfully",
    )


@router.put(
    "/events/{event_id}",
    response_model=StandardResponse[CalendarEventResponse],
    status_code=status.HTTP_200_OK,
    summary="Update event",
    description="Update a calendar event. Requires calendar.events.manage permission.",
)
async def update_event(
    event_id: Annotated[UUID, Path(..., description="Event ID")],
    current_user: Annotated[User, Depends(require_permission("calendar.events.manage"))],
    service: Annotated[CalendarService, Depends(get_calendar_service)],
    event_data: CalendarEventUpdate,
) -> StandardResponse[CalendarEventResponse]:
    """Update a calendar event."""
    event = service.update_event(
        event_id=event_id,
        tenant_id=current_user.tenant_id,
        event_data=event_data.model_dump(exclude_none=True),
    )

    if not event:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="EVENT_NOT_FOUND",
            message=f"Event with ID {event_id} not found",
        )

    return StandardResponse(
        data=CalendarEventResponse.model_validate(event),
        message="Event updated successfully",
    )


@router.post(
    "/events/{event_id}/cancel",
    response_model=StandardResponse[CalendarEventResponse],
    status_code=status.HTTP_200_OK,
    summary="Cancel event",
    description="Cancel a calendar event. Requires calendar.events.manage permission.",
)
async def cancel_event(
    event_id: Annotated[UUID, Path(..., description="Event ID")],
    current_user: Annotated[User, Depends(require_permission("calendar.events.manage"))],
    service: Annotated[CalendarService, Depends(get_calendar_service)],
) -> StandardResponse[CalendarEventResponse]:
    """Cancel a calendar event."""
    event = service.cancel_event(event_id, current_user.tenant_id)
    if not event:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="EVENT_NOT_FOUND",
            message=f"Event with ID {event_id} not found",
        )

    return StandardResponse(
        data=CalendarEventResponse.model_validate(event),
        message="Event cancelled successfully",
    )


@router.delete(
    "/events/{event_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Delete event",
    description="Delete a calendar event. Requires calendar.events.manage permission.",
)
async def delete_event(
    event_id: Annotated[UUID, Path(..., description="Event ID")],
    current_user: Annotated[User, Depends(require_permission("calendar.events.manage"))],
    service: Annotated[CalendarService, Depends(get_calendar_service)],
) -> None:
    """Delete a calendar event."""
    success = service.delete_event(event_id, current_user.tenant_id)
    if not success:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="EVENT_NOT_FOUND",
            message=f"Event with ID {event_id} not found",
        )


# Attendee endpoints
@router.post(
    "/events/{event_id}/attendees",
    response_model=StandardResponse[EventAttendeeResponse],
    status_code=status.HTTP_201_CREATED,
    summary="Add attendee",
    description="Add an attendee to an event. Requires calendar.events.manage permission.",
)
async def add_attendee(
    event_id: Annotated[UUID, Path(..., description="Event ID")],
    attendee_data: EventAttendeeCreate,
    current_user: Annotated[User, Depends(require_permission("calendar.events.manage"))],
    service: Annotated[CalendarService, Depends(get_calendar_service)],
) -> StandardResponse[EventAttendeeResponse]:
    """Add an attendee to an event."""
    attendee = service.add_attendee(
        event_id=event_id,
        tenant_id=current_user.tenant_id,
        attendee_data=attendee_data.model_dump(exclude_none=True),
    )

    return StandardResponse(
        data=EventAttendeeResponse.model_validate(attendee),
        message="Attendee added successfully",
    )


@router.put(
    "/events/{event_id}/attendees/me",
    response_model=StandardResponse[EventAttendeeResponse],
    status_code=status.HTTP_200_OK,
    summary="Update attendee response",
    description="Update your response to an event invitation. Requires calendar.events.view permission.",
)
async def update_attendee_response(
    event_id: Annotated[UUID, Path(..., description="Event ID")],
    status: Annotated[str, Query(..., description="Response status (accepted, declined, tentative)")],
    current_user: Annotated[User, Depends(require_permission("calendar.events.view"))],
    service: Annotated[CalendarService, Depends(get_calendar_service)],
    comment: str | None = Query(None, description="Optional comment"),
) -> StandardResponse[EventAttendeeResponse]:
    """Update your response to an event invitation."""
    attendee = service.update_attendee_response(
        event_id=event_id,
        user_id=current_user.id,
        tenant_id=current_user.tenant_id,
        status=status,
        comment=comment,
    )

    if not attendee:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="ATTENDEE_NOT_FOUND",
            message="You are not an attendee of this event",
        )

    return StandardResponse(
        data=EventAttendeeResponse.model_validate(attendee),
        message="Response updated successfully",
    )


# Reminder endpoints
@router.post(
    "/events/{event_id}/reminders",
    response_model=StandardResponse[EventReminderResponse],
    status_code=status.HTTP_201_CREATED,
    summary="Add reminder",
    description="Add a reminder to an event. Requires calendar.events.manage permission.",
)
async def add_reminder(
    event_id: Annotated[UUID, Path(..., description="Event ID")],
    reminder_data: EventReminderCreate,
    current_user: Annotated[User, Depends(require_permission("calendar.events.manage"))],
    service: Annotated[CalendarService, Depends(get_calendar_service)],
) -> StandardResponse[EventReminderResponse]:
    """Add a reminder to an event."""
    reminder = service.add_reminder(
        event_id=event_id,
        tenant_id=current_user.tenant_id,
        reminder_data=reminder_data.model_dump(exclude_none=True),
    )

    return StandardResponse(
        data=EventReminderResponse.model_validate(reminder),
        message="Reminder added successfully",
    )





"""Comments router for comments and collaboration management."""

from typing import Annotated
from uuid import UUID

from fastapi import APIRouter, Depends, Path, Query, status
from sqlalchemy.orm import Session

from app.core.auth.dependencies import require_permission
from app.core.comments.service import CommentService
from app.core.db.deps import get_db
from app.core.exceptions import APIException
from app.models.user import User
from app.schemas.comment import (
    CommentAttachmentCreate,
    CommentAttachmentResponse,
    CommentCreate,
    CommentResponse,
    CommentUpdate,
    CommentMentionResponse,
)
from app.schemas.common import StandardListResponse, StandardResponse

router = APIRouter()


def get_comment_service(
    db: Annotated[Session, Depends(get_db)],
) -> CommentService:
    """Dependency to get CommentService."""
    return CommentService(db)


# Comment endpoints
@router.post(
    "",
    response_model=StandardResponse[CommentResponse],
    status_code=status.HTTP_201_CREATED,
    summary="Create comment",
    description="Create a new comment. Requires comments.create permission.",
)
async def create_comment(
    comment_data: CommentCreate,
    current_user: Annotated[User, Depends(require_permission("comments.create"))],
    service: Annotated[CommentService, Depends(get_comment_service)],
) -> StandardResponse[CommentResponse]:
    """Create a new comment."""
    comment = service.create_comment(
        comment_data=comment_data.model_dump(exclude_none=True),
        tenant_id=current_user.tenant_id,
        user_id=current_user.id,
    )

    return StandardResponse(
        data=CommentResponse.model_validate(comment),
        message="Comment created successfully",
    )


@router.get(
    "",
    response_model=StandardListResponse[CommentResponse],
    status_code=status.HTTP_200_OK,
    summary="List comments",
    description="List comments for an entity. Requires comments.view permission.",
)
async def list_comments(
    entity_type: Annotated[str, Query(..., description="Entity type (e.g., 'product', 'order')")],
    entity_id: Annotated[UUID, Query(..., description="Entity ID")],
    current_user: Annotated[User, Depends(require_permission("comments.view"))],
    service: Annotated[CommentService, Depends(get_comment_service)],
    include_deleted: bool = Query(False, description="Include deleted comments"),
    page: int = Query(default=1, ge=1, description="Page number"),
    page_size: int = Query(default=20, ge=1, le=100, description="Page size"),
) -> StandardListResponse[CommentResponse]:
    """List comments for an entity."""
    skip = (page - 1) * page_size
    comments = service.get_comments_by_entity(
        entity_type=entity_type,
        entity_id=entity_id,
        tenant_id=current_user.tenant_id,
        include_deleted=include_deleted,
        skip=skip,
        limit=page_size,
    )

    total = len(comments)
    total_pages = (total + page_size - 1) // page_size if total > 0 else 0

    return StandardListResponse(
        data=[CommentResponse.model_validate(c) for c in comments],
        total=total,
        page=page,
        page_size=page_size,
        total_pages=total_pages,
        message="Comments retrieved successfully",
    )


@router.get(
    "/{comment_id}",
    response_model=StandardResponse[CommentResponse],
    status_code=status.HTTP_200_OK,
    summary="Get comment",
    description="Get a specific comment by ID. Requires comments.view permission.",
)
async def get_comment(
    comment_id: Annotated[UUID, Path(..., description="Comment ID")],
    current_user: Annotated[User, Depends(require_permission("comments.view"))],
    service: Annotated[CommentService, Depends(get_comment_service)],
) -> StandardResponse[CommentResponse]:
    """Get a specific comment."""
    comment = service.get_comment(comment_id, current_user.tenant_id)
    if not comment:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="COMMENT_NOT_FOUND",
            message=f"Comment with ID {comment_id} not found",
        )

    return StandardResponse(
        data=CommentResponse.model_validate(comment),
        message="Comment retrieved successfully",
    )


@router.get(
    "/{comment_id}/thread",
    response_model=StandardListResponse[CommentResponse],
    status_code=status.HTTP_200_OK,
    summary="Get comment thread",
    description="Get replies to a comment. Requires comments.view permission.",
)
async def get_comment_thread(
    comment_id: Annotated[UUID, Path(..., description="Parent comment ID")],
    current_user: Annotated[User, Depends(require_permission("comments.view"))],
    service: Annotated[CommentService, Depends(get_comment_service)],
    include_deleted: bool = Query(False, description="Include deleted comments"),
) -> StandardListResponse[CommentResponse]:
    """Get comment thread (replies)."""
    replies = service.get_comment_thread(
        parent_id=comment_id,
        tenant_id=current_user.tenant_id,
        include_deleted=include_deleted,
    )

    return StandardListResponse(
        data=[CommentResponse.model_validate(r) for r in replies],
        total=len(replies),
        page=1,
        page_size=len(replies),
        total_pages=1,
        message="Comment thread retrieved successfully",
    )


@router.put(
    "/{comment_id}",
    response_model=StandardResponse[CommentResponse],
    status_code=status.HTTP_200_OK,
    summary="Update comment",
    description="Update a comment. Requires comments.edit permission.",
)
async def update_comment(
    comment_id: Annotated[UUID, Path(..., description="Comment ID")],
    current_user: Annotated[User, Depends(require_permission("comments.edit"))],
    service: Annotated[CommentService, Depends(get_comment_service)],
    comment_data: CommentUpdate,
) -> StandardResponse[CommentResponse]:
    """Update a comment."""
    comment = service.update_comment(
        comment_id=comment_id,
        tenant_id=current_user.tenant_id,
        comment_data=comment_data.model_dump(exclude_none=True),
    )

    if not comment:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="COMMENT_NOT_FOUND",
            message=f"Comment with ID {comment_id} not found",
        )

    return StandardResponse(
        data=CommentResponse.model_validate(comment),
        message="Comment updated successfully",
    )


@router.delete(
    "/{comment_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Delete comment",
    description="Delete a comment (soft delete). Requires comments.delete permission.",
)
async def delete_comment(
    comment_id: Annotated[UUID, Path(..., description="Comment ID")],
    current_user: Annotated[User, Depends(require_permission("comments.delete"))],
    service: Annotated[CommentService, Depends(get_comment_service)],
) -> None:
    """Delete a comment."""
    success = service.delete_comment(comment_id, current_user.tenant_id)
    if not success:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="COMMENT_NOT_FOUND",
            message=f"Comment with ID {comment_id} not found",
        )


# Comment Attachment endpoints
@router.post(
    "/{comment_id}/attachments",
    response_model=StandardResponse[CommentAttachmentResponse],
    status_code=status.HTTP_201_CREATED,
    summary="Add attachment",
    description="Add an attachment to a comment. Requires comments.create permission.",
)
async def add_attachment(
    comment_id: Annotated[UUID, Path(..., description="Comment ID")],
    current_user: Annotated[User, Depends(require_permission("comments.create"))],
    service: Annotated[CommentService, Depends(get_comment_service)],
    attachment_data: CommentAttachmentCreate,
) -> StandardResponse[CommentAttachmentResponse]:
    """Add an attachment to a comment."""
    attachment = service.add_attachment(
        comment_id=comment_id,
        file_id=attachment_data.file_id,
        tenant_id=current_user.tenant_id,
    )

    return StandardResponse(
        data=CommentAttachmentResponse.model_validate(attachment),
        message="Attachment added successfully",
    )


@router.get(
    "/{comment_id}/attachments",
    response_model=StandardListResponse[CommentAttachmentResponse],
    status_code=status.HTTP_200_OK,
    summary="Get attachments",
    description="Get attachments for a comment. Requires comments.view permission.",
)
async def get_attachments(
    comment_id: Annotated[UUID, Path(..., description="Comment ID")],
    current_user: Annotated[User, Depends(require_permission("comments.view"))],
    service: Annotated[CommentService, Depends(get_comment_service)],
) -> StandardListResponse[CommentAttachmentResponse]:
    """Get attachments for a comment."""
    attachments = service.get_attachments(comment_id, current_user.tenant_id)

    return StandardListResponse(
        data=[CommentAttachmentResponse.model_validate(a) for a in attachments],
        total=len(attachments),
        page=1,
        page_size=len(attachments),
        total_pages=1,
        message="Attachments retrieved successfully",
    )





"""Configuration management router for module configurations."""

from typing import Annotated, Any
from uuid import UUID

from fastapi import APIRouter, Depends, Request, status
from sqlalchemy.orm import Session

from app.core.auth.dependencies import require_permission
from app.core.config.service import ConfigService
from app.core.db.deps import get_db
from app.core.exceptions import APIException, raise_bad_request, raise_not_found
from app.core.logging import get_client_info
from app.core.module_registry import get_module_registry
from app.models.user import User
from app.schemas.common import StandardListResponse, StandardResponse
from app.schemas.config import (
    ConfigUpdate,
    ModuleConfigResponse,
    ModuleInfoResponse,
    ModuleListItem,
)

router = APIRouter()


# Module management endpoints (must come before /{module} routes)
@router.get(
    "/modules",
    response_model=StandardListResponse[ModuleListItem],
    status_code=status.HTTP_200_OK,
    summary="List all modules",
    description="List all available modules with their enabled status. Requires config.view permission.",
    responses={
        200: {"description": "List of modules retrieved successfully"},
        403: {
            "description": "Insufficient permissions",
            "content": {
                "application/json": {
                    "example": {
                        "error": {
                            "code": "AUTH_INSUFFICIENT_PERMISSIONS",
                            "message": "Insufficient permissions",
                            "details": {"required_permission": "config.view"},
                        }
                    }
                }
            },
        },
    },
)
async def list_modules(
    current_user: Annotated[User, Depends(require_permission("config.view"))],
    db: Annotated[Session, Depends(get_db)],
) -> StandardListResponse[ModuleListItem]:
    """
    List all available modules with their enabled status.

    Requires: config.view

    Args:
        current_user: Current authenticated user (must have config.view).
        db: Database session.

    Returns:
        StandardListResponse with list of modules.
    """
    try:
        registry = get_module_registry()
    except RuntimeError:
        # Registry not initialized yet, return empty list
        return StandardListResponse(data=[], meta={"total": 0})

    config_service = ConfigService(db)
    modules_list = []

    for module_id, module_instance in registry.get_all_modules().items():
        is_enabled = registry.is_module_enabled(module_id, current_user.tenant_id)

        modules_list.append(
            ModuleListItem(
                id=module_id,
                name=module_instance.module_name,
                type=module_instance.module_type,
                enabled=is_enabled,
                dependencies=module_instance.get_dependencies(),
                description=module_instance.description,
            )
        )

    return StandardListResponse(
        data=modules_list, meta={"total": len(modules_list)}
    )


@router.get(
    "/modules/{module_id}",
    response_model=StandardResponse[ModuleInfoResponse],
    status_code=status.HTTP_200_OK,
    summary="Get module info",
    description="Get detailed information about a module. Requires config.view permission.",
    responses={
        200: {"description": "Module information retrieved successfully"},
        403: {
            "description": "Insufficient permissions",
            "content": {
                "application/json": {
                    "example": {
                        "error": {
                            "code": "AUTH_INSUFFICIENT_PERMISSIONS",
                            "message": "Insufficient permissions",
                            "details": {"required_permission": "config.view"},
                        }
                    }
                }
            },
        },
        404: {
            "description": "Module not found",
            "content": {
                "application/json": {
                    "example": {
                        "error": {
                            "code": "MODULE_NOT_FOUND",
                            "message": "Module 'inventory' not found",
                            "details": {"module_id": "inventory"},
                        }
                    }
                }
            },
        },
    },
)
async def get_module_info(
    module_id: str,
    current_user: Annotated[User, Depends(require_permission("config.view"))],
    db: Annotated[Session, Depends(get_db)],
) -> StandardResponse[ModuleInfoResponse]:
    """
    Get detailed information about a module.

    Requires: config.view

    Args:
        module_id: Module identifier (e.g., 'products', 'auth').
        current_user: Current authenticated user (must have config.view).
        db: Database session.

    Returns:
        StandardResponse with module information.

    Raises:
        APIException: If module not found or user lacks permission.
    """
    try:
        registry = get_module_registry()
    except RuntimeError:
        raise_not_found("Module", module_id)

    module = registry.get_module(module_id)
    if not module:
        raise_not_found("Module", module_id)

    is_enabled = registry.is_module_enabled(module_id, current_user.tenant_id)

    return StandardResponse(
        data=ModuleInfoResponse(
            id=module_id,
            name=module.module_name,
            type=module.module_type,
            enabled=is_enabled,
            dependencies=module.get_dependencies(),
            description=module.description,
            has_router=module.get_router() is not None,
            model_count=len(module.get_models()),
        )
    )


@router.put(
    "/modules/{module_id}/enable",
    response_model=StandardResponse[dict],
    status_code=status.HTTP_200_OK,
    summary="Enable module",
    description="Enable a module for the current tenant. Requires config.edit permission.",
    responses={
        200: {"description": "Module enabled successfully"},
        400: {
            "description": "Invalid request or dependency not met",
            "content": {
                "application/json": {
                    "example": {
                        "error": {
                            "code": "MODULE_DEPENDENCY_NOT_MET",
                            "message": "Cannot enable 'inventory': required dependency 'products' is not enabled",
                            "details": {"module_id": "inventory", "missing_dependency": "products"},
                        }
                    }
                }
            },
        },
        403: {
            "description": "Insufficient permissions",
            "content": {
                "application/json": {
                    "example": {
                        "error": {
                            "code": "AUTH_INSUFFICIENT_PERMISSIONS",
                            "message": "Insufficient permissions",
                            "details": {"required_permission": "config.edit"},
                        }
                    }
                }
            },
        },
        404: {
            "description": "Module not found",
            "content": {
                "application/json": {
                    "example": {
                        "error": {
                            "code": "MODULE_NOT_FOUND",
                            "message": "Module 'inventory' not found",
                            "details": {"module_id": "inventory"},
                        }
                    }
                }
            },
        },
    },
)
async def enable_module(
    module_id: str,
    current_user: Annotated[User, Depends(require_permission("config.edit"))],
    db: Annotated[Session, Depends(get_db)],
) -> StandardResponse[dict]:
    """
    Enable a module for the current tenant.

    Validates dependencies before enabling.

    Requires: config.edit

    Args:
        module_id: Module identifier.
        current_user: Current authenticated user (must have config.edit).
        db: Database session.

    Returns:
        StandardResponse with success message.

    Raises:
        APIException: If module not found, dependencies not met, or user lacks permission.
    """
    try:
        registry = get_module_registry()
    except RuntimeError:
        raise_not_found("Module", module_id)

    if module_id not in registry.get_all_modules():
        raise_not_found("Module", module_id)

    module = registry.get_module(module_id)

    # Validate dependencies
    dependencies = module.get_dependencies()
    for dep_id in dependencies:
        if not registry.is_module_enabled(dep_id, current_user.tenant_id):
            raise_bad_request(
                "MODULE_DEPENDENCY_NOT_MET",
                f"Cannot enable '{module_id}': required dependency '{dep_id}' is not enabled",
                details={"module_id": module_id, "missing_dependency": dep_id},
            )

    # Save configuration
    config_service = ConfigService(db)
    config_service.set(
        tenant_id=current_user.tenant_id,
        module="system",
        key=f"modules.{module_id}.enabled",
        value=True,
    )

    return StandardResponse(
        data={
            "module_id": module_id,
            "enabled": True,
            "message": f"Module '{module_id}' enabled successfully",
        }
    )


@router.put(
    "/modules/{module_id}/disable",
    response_model=StandardResponse[dict],
    status_code=status.HTTP_200_OK,
    summary="Disable module",
    description="Disable a module for the current tenant. Requires config.edit permission.",
    responses={
        200: {"description": "Module disabled successfully"},
        400: {
            "description": "Invalid request or module has dependencies",
            "content": {
                "application/json": {
                    "example": {
                        "error": {
                            "code": "MODULE_HAS_DEPENDENCIES",
                            "message": "Cannot disable 'products': the following enabled modules depend on it: inventory",
                            "details": {"module_id": "products", "dependent_modules": ["inventory"]},
                        }
                    }
                }
            },
        },
        403: {
            "description": "Insufficient permissions",
            "content": {
                "application/json": {
                    "example": {
                        "error": {
                            "code": "AUTH_INSUFFICIENT_PERMISSIONS",
                            "message": "Insufficient permissions",
                            "details": {"required_permission": "config.edit"},
                        }
                    }
                }
            },
        },
        404: {
            "description": "Module not found",
            "content": {
                "application/json": {
                    "example": {
                        "error": {
                            "code": "MODULE_NOT_FOUND",
                            "message": "Module 'inventory' not found",
                            "details": {"module_id": "inventory"},
                        }
                    }
                }
            },
        },
    },
)
async def disable_module(
    module_id: str,
    current_user: Annotated[User, Depends(require_permission("config.edit"))],
    db: Annotated[Session, Depends(get_db)],
) -> StandardResponse[dict]:
    """
    Disable a module for the current tenant.

    Validates that no other enabled modules depend on this module before disabling.
    Does not allow disabling critical core modules (auth, users).

    Requires: config.edit

    Args:
        module_id: Module identifier.
        current_user: Current authenticated user (must have config.edit).
        db: Database session.

    Returns:
        StandardResponse with success message.

    Raises:
        APIException: If module not found, has dependencies, is critical core module, or user lacks permission.
    """
    try:
        registry = get_module_registry()
    except RuntimeError:
        raise_not_found("Module", module_id)

    if module_id not in registry.get_all_modules():
        raise_not_found("Module", module_id)

    module = registry.get_module(module_id)

    # Verify that no enabled modules depend on this one
    dependent_modules = []
    for other_id, other_module in registry.get_all_modules().items():
        if other_id != module_id:
            if module_id in other_module.get_dependencies():
                if registry.is_module_enabled(other_id, current_user.tenant_id):
                    dependent_modules.append(other_id)

    if dependent_modules:
        raise_bad_request(
            "MODULE_HAS_DEPENDENCIES",
            f"Cannot disable '{module_id}': the following enabled modules depend on it: {', '.join(dependent_modules)}",
            details={"module_id": module_id, "dependent_modules": dependent_modules},
        )

    # Do not allow disabling critical core modules
    if module.module_type == "core" and module_id in ["auth", "users"]:
        raise_bad_request(
            "CANNOT_DISABLE_CORE_MODULE",
            f"Cannot disable core module '{module_id}'",
            details={"module_id": module_id, "reason": "critical_core_module"},
        )

    # Save configuration
    config_service = ConfigService(db)
    config_service.set(
        tenant_id=current_user.tenant_id,
        module="system",
        key=f"modules.{module_id}.enabled",
        value=False,
    )

    return StandardResponse(
        data={
            "module_id": module_id,
            "enabled": False,
            "message": f"Module '{module_id}' disabled successfully",
        }
    )


@router.get(
    "/{module}",
    response_model=StandardResponse[ModuleConfigResponse],
    status_code=status.HTTP_200_OK,
    summary="Get module configuration",
    description="Get all configuration for a specific module in the current tenant. Requires config.view permission.",
    responses={
        200: {"description": "Module configuration retrieved successfully"},
        403: {
            "description": "Insufficient permissions",
            "content": {
                "application/json": {
                    "example": {
                        "error": {
                            "code": "AUTH_INSUFFICIENT_PERMISSIONS",
                            "message": "Insufficient permissions",
                            "details": {"required_permission": "config.view"},
                        }
                    }
                }
            },
        },
    },
)
async def get_module_config(
    module: str,
    current_user: Annotated[User, Depends(require_permission("config.view"))],
    db: Annotated[Session, Depends(get_db)],
) -> StandardResponse[ModuleConfigResponse]:
    """
    Get all configuration for a specific module.

    Requires: config.view

    Args:
        module: Module name (e.g., 'products', 'inventory').
        current_user: Current authenticated user (must have config.view).
        db: Database session.

    Returns:
        StandardResponse with module configuration.

    Raises:
        APIException: If user lacks permission or module not found.
    """
    config_service = ConfigService(db)
    config_dict = config_service.get_module_config(
        tenant_id=current_user.tenant_id, module=module
    )

    return StandardResponse(
        data=ModuleConfigResponse(module=module, config=config_dict)
    )


@router.get(
    "/{module}/{key}",
    response_model=StandardResponse[dict],
    status_code=status.HTTP_200_OK,
    summary="Get configuration value",
    description="Get a specific configuration value for a module. Requires config.view permission.",
    responses={
        200: {"description": "Configuration value retrieved successfully"},
        403: {
            "description": "Insufficient permissions",
            "content": {
                "application/json": {
                    "example": {
                        "error": {
                            "code": "AUTH_INSUFFICIENT_PERMISSIONS",
                            "message": "Insufficient permissions",
                            "details": {"required_permission": "config.view"},
                        }
                    }
                }
            },
        },
        404: {
            "description": "Configuration not found",
            "content": {
                "application/json": {
                    "example": {
                        "error": {
                            "code": "CONFIG_NOT_FOUND",
                            "message": "Configuration 'products.min_price' not found",
                            "details": {"module": "products", "key": "min_price"},
                        }
                    }
                }
            },
        },
    },
)
async def get_config_value(
    module: str,
    key: str,
    current_user: Annotated[User, Depends(require_permission("config.view"))],
    db: Annotated[Session, Depends(get_db)],
) -> StandardResponse[dict]:
    """
    Get a specific configuration value.

    Requires: config.view

    Args:
        module: Module name (e.g., 'products', 'inventory').
        key: Configuration key.
        current_user: Current authenticated user (must have config.view).
        db: Database session.

    Returns:
        StandardResponse with configuration value.

    Raises:
        APIException: If user lacks permission or configuration not found.
    """
    config_service = ConfigService(db)
    value = config_service.get(
        tenant_id=current_user.tenant_id, module=module, key=key
    )

    if value is None:
        raise APIException(
            code="CONFIG_NOT_FOUND",
            message=f"Configuration '{module}.{key}' not found",
            status_code=status.HTTP_404_NOT_FOUND,
            details={"module": module, "key": key},
        )

    return StandardResponse(
        data={"module": module, "key": key, "value": value}
    )


@router.post(
    "/{module}",
    response_model=StandardResponse[ModuleConfigResponse],
    status_code=status.HTTP_201_CREATED,
    summary="Set module configuration",
    description="Set multiple configuration values for a module. Requires config.edit permission.",
    responses={
        201: {"description": "Module configuration set successfully"},
        400: {
            "description": "Invalid request or validation failed",
            "content": {
                "application/json": {
                    "example": {
                        "error": {
                            "code": "INVALID_CONFIG_VALUE",
                            "message": "Invalid value for products.min_price: value does not match schema",
                            "details": None,
                        }
                    }
                }
            },
        },
        403: {
            "description": "Insufficient permissions",
            "content": {
                "application/json": {
                    "example": {
                        "error": {
                            "code": "AUTH_INSUFFICIENT_PERMISSIONS",
                            "message": "Insufficient permissions",
                            "details": {"required_permission": "config.edit"},
                        }
                    }
                }
            },
        },
    },
)
async def set_module_config(
    module: str,
    config_data: dict[str, Any],
    request: Request,
    current_user: Annotated[User, Depends(require_permission("config.edit"))],
    db: Annotated[Session, Depends(get_db)],
) -> StandardResponse[ModuleConfigResponse]:
    """
    Set multiple configuration values for a module.

    Requires: config.edit

    Args:
        module: Module name (e.g., 'products', 'inventory').
        config_data: Dictionary of key-value pairs to set.
        current_user: Current authenticated user (must have config.edit).
        db: Database session.

    Returns:
        StandardResponse with updated module configuration.

    Raises:
        APIException: If user lacks permission or validation fails.
    """
    if not isinstance(config_data, dict):
        raise_bad_request(
            "INVALID_CONFIG_DATA",
            "Configuration data must be a dictionary",
        )

    config_service = ConfigService(db)
    ip_address, user_agent = get_client_info(request)

    try:
        config_dict = config_service.set_module_config(
            tenant_id=current_user.tenant_id, module=module, config_dict=config_data
        )
    except ValueError as e:
        raise_bad_request("INVALID_CONFIG_VALUE", str(e))

    return StandardResponse(
        data=ModuleConfigResponse(module=module, config=config_dict)
    )


@router.put(
    "/{module}/{key}",
    response_model=StandardResponse[dict],
    status_code=status.HTTP_200_OK,
    summary="Set configuration value",
    description="Set or update a specific configuration value. Requires config.edit permission.",
    responses={
        200: {"description": "Configuration value set successfully"},
        400: {
            "description": "Invalid request or validation failed",
            "content": {
                "application/json": {
                    "example": {
                        "error": {
                            "code": "INVALID_CONFIG_VALUE",
                            "message": "Invalid value for products.min_price: value does not match schema",
                            "details": None,
                        }
                    }
                }
            },
        },
        403: {
            "description": "Insufficient permissions",
            "content": {
                "application/json": {
                    "example": {
                        "error": {
                            "code": "AUTH_INSUFFICIENT_PERMISSIONS",
                            "message": "Insufficient permissions",
                            "details": {"required_permission": "config.edit"},
                        }
                    }
                }
            },
        },
    },
)
async def set_config_value(
    module: str,
    key: str,
    config_update: ConfigUpdate,
    request: Request,
    current_user: Annotated[User, Depends(require_permission("config.edit"))],
    db: Annotated[Session, Depends(get_db)],
) -> StandardResponse[dict]:
    """
    Set or update a specific configuration value.

    Requires: config.edit

    Args:
        module: Module name (e.g., 'products', 'inventory').
        key: Configuration key.
        config_update: Configuration update data.
        current_user: Current authenticated user (must have config.edit).
        db: Database session.

    Returns:
        StandardResponse with updated configuration.

    Raises:
        APIException: If user lacks permission or validation fails.
    """
    config_service = ConfigService(db)
    ip_address, user_agent = get_client_info(request)

    try:
        config_data = config_service.set(
            tenant_id=current_user.tenant_id,
            module=module,
            key=key,
            value=config_update.value,
        )
    except ValueError as e:
        raise_bad_request("INVALID_CONFIG_VALUE", str(e))

    return StandardResponse(data=config_data)


@router.delete(
    "/{module}/{key}",
    response_model=StandardResponse[dict],
    status_code=status.HTTP_200_OK,
    summary="Delete configuration value",
    description="Delete a specific configuration value. Requires config.delete permission.",
    responses={
        200: {"description": "Configuration value deleted successfully"},
        403: {
            "description": "Insufficient permissions",
            "content": {
                "application/json": {
                    "example": {
                        "error": {
                            "code": "AUTH_INSUFFICIENT_PERMISSIONS",
                            "message": "Insufficient permissions",
                            "details": {"required_permission": "config.delete"},
                        }
                    }
                }
            },
        },
        404: {
            "description": "Configuration not found",
            "content": {
                "application/json": {
                    "example": {
                        "error": {
                            "code": "CONFIG_NOT_FOUND",
                            "message": "Configuration 'products.min_price' not found",
                            "details": {"module": "products", "key": "min_price"},
                        }
                    }
                }
            },
        },
    },
)
async def delete_config_value(
    module: str,
    key: str,
    current_user: Annotated[User, Depends(require_permission("config.delete"))],
    db: Annotated[Session, Depends(get_db)],
) -> StandardResponse[dict]:
    """
    Delete a specific configuration value.

    Requires: config.delete

    Args:
        module: Module name (e.g., 'products', 'inventory').
        key: Configuration key.
        current_user: Current authenticated user (must have config.delete).
        db: Database session.

    Returns:
        StandardResponse with success message.

    Raises:
        APIException: If user lacks permission or configuration not found.
    """
    config_service = ConfigService(db)

    # Check if exists before deleting
    value = config_service.get(
        tenant_id=current_user.tenant_id, module=module, key=key
    )
    if value is None:
        raise APIException(
            code="CONFIG_NOT_FOUND",
            message=f"Configuration '{module}.{key}' not found",
            status_code=status.HTTP_404_NOT_FOUND,
            details={"module": module, "key": key},
        )

    config_service.delete(
        tenant_id=current_user.tenant_id, module=module, key=key
    )

    return StandardResponse(
        data={"message": f"Configuration '{module}.{key}' deleted successfully"}
    )




"""Files router for file and document management."""

from typing import Annotated
from uuid import UUID

from fastapi import APIRouter, Depends, File as FastAPIFile, Path, Query, UploadFile, status
from fastapi.responses import Response, StreamingResponse
from sqlalchemy.orm import Session

from app.core.auth.dependencies import require_permission
from app.core.db.deps import get_db
from app.core.exceptions import APIException
from app.core.files.service import FileService
from app.models.user import User
from app.schemas.common import StandardListResponse, StandardResponse
from app.schemas.file import (
    FilePermissionRequest,
    FilePermissionResponse,
    FileResponse,
    FileUpdate,
    FileVersionResponse,
)

router = APIRouter()


def get_file_service(
    db: Annotated[Session, Depends(get_db)],
) -> FileService:
    """Dependency to get FileService."""
    return FileService(db)


@router.post(
    "/upload",
    response_model=StandardResponse[FileResponse],
    status_code=status.HTTP_201_CREATED,
    summary="Upload file",
    description="Upload a new file. Requires files.manage permission.",
)
async def upload_file(
    current_user: Annotated[User, Depends(require_permission("files.manage"))],
    service: Annotated[FileService, Depends(get_file_service)],
    file: UploadFile = FastAPIFile(..., description="File to upload"),
    entity_type: str | None = Query(default=None, description="Entity type (e.g., 'product', 'order')"),
    entity_id: UUID | None = Query(default=None, description="Entity ID"),
    description: str | None = Query(default=None, description="File description"),
) -> StandardResponse[FileResponse]:
    """Upload a new file."""
    # Read file content
    content = await file.read()

    uploaded_file = await service.upload_file(
        file_content=content,
        filename=file.filename or "unnamed",
        entity_type=entity_type,
        entity_id=entity_id,
        tenant_id=current_user.tenant_id,
        user_id=current_user.id,
        description=description,
    )

    return StandardResponse(
        data=FileResponse.model_validate(uploaded_file),
        message="File uploaded successfully",
    )


@router.get(
    "/{file_id}",
    response_model=StandardResponse[FileResponse],
    status_code=status.HTTP_200_OK,
    summary="Get file information",
    description="Get file information by ID. Requires files.view permission.",
)
async def get_file_info(
    file_id: Annotated[UUID, Path(..., description="File ID")],
    current_user: Annotated[User, Depends(require_permission("files.view"))],
    service: Annotated[FileService, Depends(get_file_service)],
) -> StandardResponse[FileResponse]:
    """Get file information."""
    file = service.repository.get_by_id(file_id, current_user.tenant_id)
    if not file or not file.is_current:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="FILE_NOT_FOUND",
            message=f"File with ID {file_id} not found",
        )

    return StandardResponse(
        data=FileResponse.model_validate(file),
        message="File retrieved successfully",
    )


@router.get(
    "/{file_id}/download",
    summary="Download file",
    description="Download file content. Requires files.view permission.",
    responses={
        200: {"description": "File content", "content": {"application/octet-stream": {}}},
        404: {"description": "File not found"},
    },
)
async def download_file(
    file_id: Annotated[UUID, Path(..., description="File ID")],
    current_user: Annotated[User, Depends(require_permission("files.view"))],
    service: Annotated[FileService, Depends(get_file_service)],
):
    """Download file content."""
    try:
        content, file = await service.download_file(file_id, current_user.tenant_id)

        return StreamingResponse(
            iter([content]),
            media_type=file.mime_type,
            headers={
                "Content-Disposition": f'attachment; filename="{file.original_name}"',
                "Content-Length": str(file.size),
            },
        )
    except FileNotFoundError:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="FILE_NOT_FOUND",
            message=f"File with ID {file_id} not found",
        )


@router.get(
    "/{file_id}/preview",
    summary="Get file preview/thumbnail",
    description="Get a preview or thumbnail of an image file. Requires files.view permission.",
    responses={
        200: {"description": "Image preview", "content": {"image/jpeg": {}}},
        404: {"description": "File not found"},
        400: {"description": "File is not an image"},
    },
)
async def get_file_preview(
    file_id: Annotated[UUID, Path(..., description="File ID")],
    current_user: Annotated[User, Depends(require_permission("files.view"))],
    service: Annotated[FileService, Depends(get_file_service)],
    width: int = Query(default=200, ge=1, le=2000, description="Preview width in pixels"),
    height: int = Query(default=200, ge=1, le=2000, description="Preview height in pixels"),
    quality: int = Query(default=80, ge=1, le=100, description="JPEG quality (1-100)"),
) -> Response:
    """Get file preview/thumbnail."""
    try:
        # Generate thumbnail
        preview_bytes = await service.generate_thumbnail(
            file_id=file_id,
            tenant_id=current_user.tenant_id,
            width=width,
            height=height,
            quality=quality,
        )

        return Response(
            content=preview_bytes,
            media_type="image/jpeg",
            headers={
                "Cache-Control": "public, max-age=3600",
                "Content-Length": str(len(preview_bytes)),
            },
        )
    except FileNotFoundError:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="FILE_NOT_FOUND",
            message=f"File with ID {file_id} not found",
        )
    except ValueError as e:
        raise APIException(
            status_code=status.HTTP_400_BAD_REQUEST,
            code="FILE_NOT_IMAGE",
            message=str(e),
        )


@router.put(
    "/{file_id}",
    response_model=StandardResponse[FileResponse],
    status_code=status.HTTP_200_OK,
    summary="Update file",
    description="Update file information. Requires files.manage permission.",
)
async def update_file(
    file_id: Annotated[UUID, Path(..., description="File ID")],
    current_user: Annotated[User, Depends(require_permission("files.manage"))],
    service: Annotated[FileService, Depends(get_file_service)],
    file_data: FileUpdate,
) -> StandardResponse[FileResponse]:
    """Update file information."""
    update_dict = file_data.model_dump(exclude_unset=True)
    file = service.repository.update(file_id, current_user.tenant_id, update_dict)

    if not file:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="FILE_NOT_FOUND",
            message=f"File with ID {file_id} not found",
        )

    return StandardResponse(
        data=FileResponse.model_validate(file),
        message="File updated successfully",
    )


@router.delete(
    "/{file_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Delete file",
    description="Delete a file (soft delete). Requires files.manage permission.",
)
async def delete_file(
    file_id: Annotated[UUID, Path(..., description="File ID")],
    current_user: Annotated[User, Depends(require_permission("files.manage"))],
    service: Annotated[FileService, Depends(get_file_service)],
) -> None:
    """Delete a file."""
    deleted = await service.delete_file(file_id, current_user.tenant_id, current_user.id)
    if not deleted:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="FILE_NOT_FOUND",
            message=f"File with ID {file_id} not found",
        )


@router.get(
    "/{file_id}/versions",
    response_model=StandardListResponse[FileVersionResponse],
    status_code=status.HTTP_200_OK,
    summary="List file versions",
    description="List all versions of a file. Requires files.view permission.",
)
async def list_file_versions(
    file_id: Annotated[UUID, Path(..., description="File ID")],
    current_user: Annotated[User, Depends(require_permission("files.view"))],
    service: Annotated[FileService, Depends(get_file_service)],
) -> StandardListResponse[FileVersionResponse]:
    """List all versions of a file."""
    # Verify file exists
    file = service.repository.get_by_id(file_id, current_user.tenant_id)
    if not file:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="FILE_NOT_FOUND",
            message=f"File with ID {file_id} not found",
        )

    versions = service.get_file_versions(file_id, current_user.tenant_id)

    return StandardListResponse(
        data=[FileVersionResponse.model_validate(v) for v in versions],
        total=len(versions),
        page=1,
        page_size=len(versions),
        total_pages=1,
        message="File versions retrieved successfully",
    )


@router.post(
    "/{file_id}/versions",
    response_model=StandardResponse[FileVersionResponse],
    status_code=status.HTTP_201_CREATED,
    summary="Create file version",
    description="Create a new version of a file. Requires files.manage permission.",
)
async def create_file_version(
    file_id: Annotated[UUID, Path(..., description="File ID")],
    current_user: Annotated[User, Depends(require_permission("files.manage"))],
    service: Annotated[FileService, Depends(get_file_service)],
    file: UploadFile = FastAPIFile(..., description="New file version"),
    change_description: str | None = Query(default=None, description="Description of changes"),
) -> StandardResponse[FileVersionResponse]:
    """Create a new version of a file."""
    # Read file content
    content = await file.read()

    version = await service.create_file_version(
        file_id=file_id,
        file_content=content,
        filename=file.filename or "unnamed",
        tenant_id=current_user.tenant_id,
        user_id=current_user.id,
        change_description=change_description,
    )

    return StandardResponse(
        data=FileVersionResponse.model_validate(version),
        message="File version created successfully",
    )


@router.get(
    "/{file_id}/versions/{version_id}/download",
    summary="Download file version",
    description="Download a specific file version. Requires files.view permission.",
)
async def download_file_version(
    file_id: Annotated[UUID, Path(..., description="File ID")],
    version_id: Annotated[UUID, Path(..., description="Version ID")],
    current_user: Annotated[User, Depends(require_permission("files.view"))],
    service: Annotated[FileService, Depends(get_file_service)],
):
    """Download a specific file version."""
    # Verify file exists
    file = service.repository.get_by_id(file_id, current_user.tenant_id)
    if not file:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="FILE_NOT_FOUND",
            message=f"File with ID {file_id} not found",
        )

    # Get version
    version = service.repository.get_version_by_id(version_id, current_user.tenant_id)
    if not version or version.file_id != file_id:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="FILE_VERSION_NOT_FOUND",
            message=f"File version with ID {version_id} not found",
        )

    # Download from storage
    content = await service.storage_backend.download(version.storage_path)

    return StreamingResponse(
        iter([content]),
        media_type=version.mime_type,
        headers={
            "Content-Disposition": f'attachment; filename="v{version.version_number}_{file.original_name}"',
            "Content-Length": str(version.size),
        },
    )


@router.put(
    "/{file_id}/permissions",
    response_model=StandardListResponse[FilePermissionResponse],
    status_code=status.HTTP_200_OK,
    summary="Update file permissions",
    description="Update file permissions. Requires files.manage permission.",
)
async def update_file_permissions(
    file_id: Annotated[UUID, Path(..., description="File ID")],
    current_user: Annotated[User, Depends(require_permission("files.manage"))],
    service: Annotated[FileService, Depends(get_file_service)],
    permissions: list[FilePermissionRequest],
) -> StandardListResponse[FilePermissionResponse]:
    """Update file permissions."""
    # Verify file exists
    file = service.repository.get_by_id(file_id, current_user.tenant_id)
    if not file:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="FILE_NOT_FOUND",
            message=f"File with ID {file_id} not found",
        )

    # Convert permissions to dicts
    permissions_data = [p.model_dump() for p in permissions]

    # Set permissions
    created_permissions = service.set_file_permissions(
        file_id, permissions_data, current_user.tenant_id
    )

    return StandardListResponse(
        data=[FilePermissionResponse.model_validate(p) for p in created_permissions],
        total=len(created_permissions),
        page=1,
        page_size=len(created_permissions),
        total_pages=1,
        message="File permissions updated successfully",
    )


@router.get(
    "",
    response_model=StandardListResponse[FileResponse],
    status_code=status.HTTP_200_OK,
    summary="List files",
    description="List all files for the current tenant. Requires files.view permission.",
)
async def list_files(
    current_user: Annotated[User, Depends(require_permission("files.view"))],
    service: Annotated[FileService, Depends(get_file_service)],
    page: int = Query(default=1, ge=1, description="Page number"),
    page_size: int = Query(default=20, ge=1, le=100, description="Page size"),
    entity_type: str | None = Query(default=None, description="Filter by entity type"),
    entity_id: UUID | None = Query(default=None, description="Filter by entity ID"),
) -> StandardListResponse[FileResponse]:
    """List all files."""
    if entity_type and entity_id:
        files = service.repository.get_by_entity(
            entity_type, entity_id, current_user.tenant_id
        )
        total = len(files)
    else:
        skip = (page - 1) * page_size
        files = service.repository.get_all(
            current_user.tenant_id, skip=skip, limit=page_size
        )
        total = len(files)  # TODO: Add count method to repository

    total_pages = (total + page_size - 1) // page_size if total > 0 else 0

    return StandardListResponse(
        data=[FileResponse.model_validate(f) for f in files],
        total=total,
        page=page,
        page_size=page_size,
        total_pages=total_pages,
        message="Files retrieved successfully",
    )


"""Import/Export router for data import and export management."""

from typing import Annotated
from uuid import UUID

from fastapi import APIRouter, Depends, File as FastAPIFile, Path, Query, UploadFile, status
from fastapi.responses import StreamingResponse
from sqlalchemy.orm import Session

from app.core.auth.dependencies import require_permission
from app.core.db.deps import get_db
from app.core.exceptions import APIException
from app.core.import_export.service import ImportExportService
from app.core.files.service import FileService
from app.models.user import User
from app.schemas.common import StandardListResponse, StandardResponse
from app.schemas.import_export import (
    ExportJobCreate,
    ExportJobResponse,
    ImportJobCreate,
    ImportJobResponse,
    ImportTemplateCreate,
    ImportTemplateResponse,
    ImportTemplateUpdate,
)

router = APIRouter()


def get_import_export_service(
    db: Annotated[Session, Depends(get_db)],
) -> ImportExportService:
    """Dependency to get ImportExportService."""
    return ImportExportService(db)


# Import Job endpoints
@router.post(
    "/import/jobs",
    response_model=StandardResponse[ImportJobResponse],
    status_code=status.HTTP_201_CREATED,
    summary="Create import job",
    description="Create a new import job. Requires import_export.import permission.",
)
async def create_import_job(
    job_data: ImportJobCreate,
    current_user: Annotated[User, Depends(require_permission("import_export.import"))],
    service: Annotated[ImportExportService, Depends(get_import_export_service)],
) -> StandardResponse[ImportJobResponse]:
    """Create a new import job."""
    job = service.create_import_job(
        job_data=job_data.model_dump(exclude_none=True),
        tenant_id=current_user.tenant_id,
        user_id=current_user.id,
    )

    return StandardResponse(
        data=ImportJobResponse.model_validate(job),
        message="Import job created successfully",
    )


@router.get(
    "/import/jobs",
    response_model=StandardListResponse[ImportJobResponse],
    status_code=status.HTTP_200_OK,
    summary="List import jobs",
    description="List import jobs. Requires import_export.view permission.",
)
async def list_import_jobs(
    current_user: Annotated[User, Depends(require_permission("import_export.view"))],
    service: Annotated[ImportExportService, Depends(get_import_export_service)],
    module: str | None = Query(default=None, description="Filter by module"),
    status: str | None = Query(default=None, description="Filter by status"),
    page: int = Query(default=1, ge=1, description="Page number"),
    page_size: int = Query(default=20, ge=1, le=100, description="Page size"),
) -> StandardListResponse[ImportJobResponse]:
    """List import jobs."""
    skip = (page - 1) * page_size
    jobs = service.repository.get_import_jobs(
        tenant_id=current_user.tenant_id,
        module=module,
        status=status,
        skip=skip,
        limit=page_size,
    )

    total = len(jobs)  # TODO: Add count method
    total_pages = (total + page_size - 1) // page_size if total > 0 else 0

    return StandardListResponse(
        data=[ImportJobResponse.model_validate(j) for j in jobs],
        total=total,
        page=page,
        page_size=page_size,
        total_pages=total_pages,
        message="Import jobs retrieved successfully",
    )


@router.get(
    "/import/jobs/{job_id}",
    response_model=StandardResponse[ImportJobResponse],
    status_code=status.HTTP_200_OK,
    summary="Get import job",
    description="Get a specific import job by ID. Requires import_export.view permission.",
)
async def get_import_job(
    job_id: Annotated[UUID, Path(..., description="Import job ID")],
    current_user: Annotated[User, Depends(require_permission("import_export.view"))],
    service: Annotated[ImportExportService, Depends(get_import_export_service)],
) -> StandardResponse[ImportJobResponse]:
    """Get a specific import job."""
    job = service.get_import_job(job_id, current_user.tenant_id)
    if not job:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="IMPORT_JOB_NOT_FOUND",
            message=f"Import job with ID {job_id} not found",
        )

    return StandardResponse(
        data=ImportJobResponse.model_validate(job),
        message="Import job retrieved successfully",
    )


# Import Template endpoints
@router.post(
    "/import/templates",
    response_model=StandardResponse[ImportTemplateResponse],
    status_code=status.HTTP_201_CREATED,
    summary="Create import template",
    description="Create a new import template. Requires import_export.manage permission.",
)
async def create_import_template(
    template_data: ImportTemplateCreate,
    current_user: Annotated[User, Depends(require_permission("import_export.manage"))],
    service: Annotated[ImportExportService, Depends(get_import_export_service)],
) -> StandardResponse[ImportTemplateResponse]:
    """Create a new import template."""
    template = service.create_import_template(
        template_data=template_data.model_dump(exclude_none=True),
        tenant_id=current_user.tenant_id,
        user_id=current_user.id,
    )

    return StandardResponse(
        data=ImportTemplateResponse.model_validate(template),
        message="Import template created successfully",
    )


@router.get(
    "/import/templates",
    response_model=StandardListResponse[ImportTemplateResponse],
    status_code=status.HTTP_200_OK,
    summary="List import templates",
    description="List import templates. Requires import_export.view permission.",
)
async def list_import_templates(
    current_user: Annotated[User, Depends(require_permission("import_export.view"))],
    service: Annotated[ImportExportService, Depends(get_import_export_service)],
    module: str | None = Query(default=None, description="Filter by module"),
    page: int = Query(default=1, ge=1, description="Page number"),
    page_size: int = Query(default=20, ge=1, le=100, description="Page size"),
) -> StandardListResponse[ImportTemplateResponse]:
    """List import templates."""
    skip = (page - 1) * page_size
    templates = service.get_import_templates(
        tenant_id=current_user.tenant_id,
        module=module,
        skip=skip,
        limit=page_size,
    )

    total = len(templates)
    total_pages = (total + page_size - 1) // page_size if total > 0 else 0

    return StandardListResponse(
        data=[ImportTemplateResponse.model_validate(t) for t in templates],
        total=total,
        page=page,
        page_size=page_size,
        total_pages=total_pages,
        message="Import templates retrieved successfully",
    )


# Export Job endpoints
@router.post(
    "/export/jobs",
    response_model=StandardResponse[ExportJobResponse],
    status_code=status.HTTP_201_CREATED,
    summary="Create export job",
    description="Create a new export job. Requires import_export.export permission.",
)
async def create_export_job(
    job_data: ExportJobCreate,
    current_user: Annotated[User, Depends(require_permission("import_export.export"))],
    service: Annotated[ImportExportService, Depends(get_import_export_service)],
) -> StandardResponse[ExportJobResponse]:
    """Create a new export job."""
    job = service.create_export_job(
        job_data=job_data.model_dump(exclude_none=True),
        tenant_id=current_user.tenant_id,
        user_id=current_user.id,
    )

    return StandardResponse(
        data=ExportJobResponse.model_validate(job),
        message="Export job created successfully",
    )


@router.get(
    "/export/jobs",
    response_model=StandardListResponse[ExportJobResponse],
    status_code=status.HTTP_200_OK,
    summary="List export jobs",
    description="List export jobs. Requires import_export.view permission.",
)
async def list_export_jobs(
    current_user: Annotated[User, Depends(require_permission("import_export.view"))],
    service: Annotated[ImportExportService, Depends(get_import_export_service)],
    module: str | None = Query(default=None, description="Filter by module"),
    status: str | None = Query(default=None, description="Filter by status"),
    page: int = Query(default=1, ge=1, description="Page number"),
    page_size: int = Query(default=20, ge=1, le=100, description="Page size"),
) -> StandardListResponse[ExportJobResponse]:
    """List export jobs."""
    skip = (page - 1) * page_size
    jobs = service.repository.get_export_jobs(
        tenant_id=current_user.tenant_id,
        module=module,
        status=status,
        skip=skip,
        limit=page_size,
    )

    total = len(jobs)
    total_pages = (total + page_size - 1) // page_size if total > 0 else 0

    return StandardListResponse(
        data=[ExportJobResponse.model_validate(j) for j in jobs],
        total=total,
        page=page,
        page_size=page_size,
        total_pages=total_pages,
        message="Export jobs retrieved successfully",
    )


@router.get(
    "/export/jobs/{job_id}",
    response_model=StandardResponse[ExportJobResponse],
    status_code=status.HTTP_200_OK,
    summary="Get export job",
    description="Get a specific export job by ID. Requires import_export.view permission.",
)
async def get_export_job(
    job_id: Annotated[UUID, Path(..., description="Export job ID")],
    current_user: Annotated[User, Depends(require_permission("import_export.view"))],
    service: Annotated[ImportExportService, Depends(get_import_export_service)],
) -> StandardResponse[ExportJobResponse]:
    """Get a specific export job."""
    job = service.get_export_job(job_id, current_user.tenant_id)
    if not job:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="EXPORT_JOB_NOT_FOUND",
            message=f"Export job with ID {job_id} not found",
        )

    return StandardResponse(
        data=ExportJobResponse.model_validate(job),
        message="Export job retrieved successfully",
    )





"""Integrations router for external integrations and webhooks."""

from typing import Annotated
from uuid import UUID

from fastapi import APIRouter, Depends, Path, Query, status
from sqlalchemy.orm import Session

from app.core.auth.dependencies import require_permission
from app.core.db.deps import get_db
from app.core.exceptions import APIException
from app.core.integrations.service import IntegrationService
from app.core.integrations.webhooks import WebhookHandler
from app.models.user import User
from app.schemas.common import StandardListResponse, StandardResponse
from app.schemas.integration import (
    IntegrationCreate,
    IntegrationLogResponse,
    IntegrationResponse,
    IntegrationUpdate,
    WebhookCreate,
    WebhookDeliveryResponse,
    WebhookResponse,
    WebhookUpdate,
)

router = APIRouter()


def get_integration_service(db: Annotated[Session, Depends(get_db)]) -> IntegrationService:
    """Dependency to get IntegrationService."""
    return IntegrationService(db)


def get_webhook_handler(db: Annotated[Session, Depends(get_db)]) -> WebhookHandler:
    """Dependency to get WebhookHandler."""
    return WebhookHandler(db)


# Integration endpoints
@router.post(
    "",
    response_model=StandardResponse[IntegrationResponse],
    status_code=status.HTTP_201_CREATED,
    summary="Create integration",
    description="Create a new integration. Requires integrations.manage permission.",
)
async def create_integration(
    integration_data: IntegrationCreate,
    current_user: Annotated[User, Depends(require_permission("integrations.manage"))],
    service: Annotated[IntegrationService, Depends(get_integration_service)],
) -> StandardResponse[IntegrationResponse]:
    """Create a new integration."""
    integration = service.create_integration(
        name=integration_data.name,
        tenant_id=current_user.tenant_id,
        integration_type=integration_data.integration_type,
        config=integration_data.config,
        credentials=integration_data.credentials,
        description=integration_data.description,
        metadata=integration_data.metadata,
    )

    return StandardResponse(
        data=IntegrationResponse.model_validate(integration),
        message="Integration created successfully",
    )


@router.get(
    "",
    response_model=StandardListResponse[IntegrationResponse],
    status_code=status.HTTP_200_OK,
    summary="List integrations",
    description="List integrations. Requires integrations.view permission.",
)
async def list_integrations(
    current_user: Annotated[User, Depends(require_permission("integrations.view"))],
    service: Annotated[IntegrationService, Depends(get_integration_service)],
    page: int = Query(default=1, ge=1, description="Page number"),
    page_size: int = Query(default=20, ge=1, le=100, description="Page size"),
    integration_type: str | None = Query(default=None, description="Filter by integration type"),
    status: str | None = Query(default=None, description="Filter by status"),
) -> StandardListResponse[IntegrationResponse]:
    """List integrations."""
    skip = (page - 1) * page_size
    integrations = service.get_integrations(
        tenant_id=current_user.tenant_id,
        integration_type=integration_type,
        status=status,
        skip=skip,
        limit=page_size,
    )
    total = len(integrations)  # TODO: Add count method to repository

    total_pages = (total + page_size - 1) // page_size if total > 0 else 0

    return StandardListResponse(
        data=[IntegrationResponse.model_validate(i) for i in integrations],
        total=total,
        page=page,
        page_size=page_size,
        total_pages=total_pages,
        message="Integrations retrieved successfully",
    )


@router.get(
    "/{integration_id}",
    response_model=StandardResponse[IntegrationResponse],
    status_code=status.HTTP_200_OK,
    summary="Get integration",
    description="Get a specific integration by ID. Requires integrations.view permission.",
)
async def get_integration(
    integration_id: Annotated[UUID, Path(..., description="Integration ID")],
    current_user: Annotated[User, Depends(require_permission("integrations.view"))],
    service: Annotated[IntegrationService, Depends(get_integration_service)],
) -> StandardResponse[IntegrationResponse]:
    """Get a specific integration."""
    integration = service.get_integration(integration_id, current_user.tenant_id)
    if not integration:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="INTEGRATION_NOT_FOUND",
            message=f"Integration with ID {integration_id} not found",
        )

    return StandardResponse(
        data=IntegrationResponse.model_validate(integration),
        message="Integration retrieved successfully",
    )


@router.put(
    "/{integration_id}",
    response_model=StandardResponse[IntegrationResponse],
    status_code=status.HTTP_200_OK,
    summary="Update integration",
    description="Update an integration. Requires integrations.manage permission.",
)
async def update_integration(
    integration_id: Annotated[UUID, Path(..., description="Integration ID")],
    current_user: Annotated[User, Depends(require_permission("integrations.manage"))],
    service: Annotated[IntegrationService, Depends(get_integration_service)],
    integration_data: IntegrationUpdate,
) -> StandardResponse[IntegrationResponse]:
    """Update an integration."""
    update_dict = integration_data.model_dump(exclude_unset=True)
    integration = service.update_integration(integration_id, current_user.tenant_id, update_dict)

    if not integration:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="INTEGRATION_NOT_FOUND",
            message=f"Integration with ID {integration_id} not found",
        )

    return StandardResponse(
        data=IntegrationResponse.model_validate(integration),
        message="Integration updated successfully",
    )


@router.delete(
    "/{integration_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Delete integration",
    description="Delete an integration. Requires integrations.manage permission.",
)
async def delete_integration(
    integration_id: Annotated[UUID, Path(..., description="Integration ID")],
    current_user: Annotated[User, Depends(require_permission("integrations.manage"))],
    service: Annotated[IntegrationService, Depends(get_integration_service)],
) -> None:
    """Delete an integration."""
    deleted = service.delete_integration(integration_id, current_user.tenant_id)
    if not deleted:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="INTEGRATION_NOT_FOUND",
            message=f"Integration with ID {integration_id} not found",
        )


@router.get(
    "/{integration_id}/logs",
    response_model=StandardListResponse[IntegrationLogResponse],
    status_code=status.HTTP_200_OK,
    summary="Get integration logs",
    description="Get logs for an integration. Requires integrations.view permission.",
)
async def get_integration_logs(
    integration_id: Annotated[UUID, Path(..., description="Integration ID")],
    current_user: Annotated[User, Depends(require_permission("integrations.view"))],
    service: Annotated[IntegrationService, Depends(get_integration_service)],
    page: int = Query(default=1, ge=1, description="Page number"),
    page_size: int = Query(default=20, ge=1, le=100, description="Page size"),
) -> StandardListResponse[IntegrationLogResponse]:
    """Get logs for an integration."""
    skip = (page - 1) * page_size
    logs = service.get_logs(integration_id, current_user.tenant_id, skip, page_size)
    total = len(logs)  # TODO: Add count method to repository

    total_pages = (total + page_size - 1) // page_size if total > 0 else 0

    return StandardListResponse(
        data=[IntegrationLogResponse.model_validate(l) for l in logs],
        total=total,
        page=page,
        page_size=page_size,
        total_pages=total_pages,
        message="Integration logs retrieved successfully",
    )


# Webhook endpoints
@router.post(
    "/webhooks",
    response_model=StandardResponse[WebhookResponse],
    status_code=status.HTTP_201_CREATED,
    summary="Create webhook",
    description="Create a new webhook. Requires integrations.manage permission.",
)
async def create_webhook(
    webhook_data: WebhookCreate,
    current_user: Annotated[User, Depends(require_permission("integrations.manage"))],
    service: Annotated[IntegrationService, Depends(get_integration_service)],
) -> StandardResponse[WebhookResponse]:
    """Create a new webhook."""
    from app.repositories.integration_repository import IntegrationRepository

    repository = IntegrationRepository(service.db)
    webhook = repository.create_webhook(
        {
            "tenant_id": current_user.tenant_id,
            "integration_id": webhook_data.integration_id,
            "name": webhook_data.name,
            "url": webhook_data.url,
            "event_type": webhook_data.event_type,
            "enabled": webhook_data.enabled,
            "method": webhook_data.method,
            "headers": webhook_data.headers,
            "secret": webhook_data.secret,
            "max_retries": webhook_data.max_retries,
            "retry_delay": webhook_data.retry_delay,
            "metadata": webhook_data.metadata,
        }
    )

    return StandardResponse(
        data=WebhookResponse.model_validate(webhook),
        message="Webhook created successfully",
    )


@router.get(
    "/webhooks",
    response_model=StandardListResponse[WebhookResponse],
    status_code=status.HTTP_200_OK,
    summary="List webhooks",
    description="List webhooks. Requires integrations.view permission.",
)
async def list_webhooks(
    current_user: Annotated[User, Depends(require_permission("integrations.view"))],
    service: Annotated[IntegrationService, Depends(get_integration_service)],
    page: int = Query(default=1, ge=1, description="Page number"),
    page_size: int = Query(default=20, ge=1, le=100, description="Page size"),
    enabled_only: bool = Query(default=False, description="Only return enabled webhooks"),
) -> StandardListResponse[WebhookResponse]:
    """List webhooks."""
    from app.repositories.integration_repository import IntegrationRepository

    repository = IntegrationRepository(service.db)
    skip = (page - 1) * page_size
    webhooks = repository.get_all_webhooks(
        current_user.tenant_id, enabled_only=enabled_only, skip=skip, limit=page_size
    )
    total = len(webhooks)  # TODO: Add count method to repository

    total_pages = (total + page_size - 1) // page_size if total > 0 else 0

    return StandardListResponse(
        data=[WebhookResponse.model_validate(w) for w in webhooks],
        total=total,
        page=page,
        page_size=page_size,
        total_pages=total_pages,
        message="Webhooks retrieved successfully",
    )


@router.get(
    "/webhooks/{webhook_id}",
    response_model=StandardResponse[WebhookResponse],
    status_code=status.HTTP_200_OK,
    summary="Get webhook",
    description="Get a specific webhook by ID. Requires integrations.view permission.",
)
async def get_webhook(
    webhook_id: Annotated[UUID, Path(..., description="Webhook ID")],
    current_user: Annotated[User, Depends(require_permission("integrations.view"))],
    service: Annotated[IntegrationService, Depends(get_integration_service)],
) -> StandardResponse[WebhookResponse]:
    """Get a specific webhook."""
    from app.repositories.integration_repository import IntegrationRepository

    repository = IntegrationRepository(service.db)
    webhook = repository.get_webhook_by_id(webhook_id, current_user.tenant_id)
    if not webhook:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="WEBHOOK_NOT_FOUND",
            message=f"Webhook with ID {webhook_id} not found",
        )

    return StandardResponse(
        data=WebhookResponse.model_validate(webhook),
        message="Webhook retrieved successfully",
    )


@router.put(
    "/webhooks/{webhook_id}",
    response_model=StandardResponse[WebhookResponse],
    status_code=status.HTTP_200_OK,
    summary="Update webhook",
    description="Update a webhook. Requires integrations.manage permission.",
)
async def update_webhook(
    webhook_id: Annotated[UUID, Path(..., description="Webhook ID")],
    current_user: Annotated[User, Depends(require_permission("integrations.manage"))],
    service: Annotated[IntegrationService, Depends(get_integration_service)],
    webhook_data: WebhookUpdate,
) -> StandardResponse[WebhookResponse]:
    """Update a webhook."""
    from app.repositories.integration_repository import IntegrationRepository

    repository = IntegrationRepository(service.db)
    update_dict = webhook_data.model_dump(exclude_unset=True)
    webhook = repository.update_webhook(webhook_id, current_user.tenant_id, update_dict)

    if not webhook:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="WEBHOOK_NOT_FOUND",
            message=f"Webhook with ID {webhook_id} not found",
        )

    return StandardResponse(
        data=WebhookResponse.model_validate(webhook),
        message="Webhook updated successfully",
    )


@router.delete(
    "/webhooks/{webhook_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Delete webhook",
    description="Delete a webhook. Requires integrations.manage permission.",
)
async def delete_webhook(
    webhook_id: Annotated[UUID, Path(..., description="Webhook ID")],
    current_user: Annotated[User, Depends(require_permission("integrations.manage"))],
    service: Annotated[IntegrationService, Depends(get_integration_service)],
) -> None:
    """Delete a webhook."""
    from app.repositories.integration_repository import IntegrationRepository

    repository = IntegrationRepository(service.db)
    deleted = repository.delete_webhook(webhook_id, current_user.tenant_id)
    if not deleted:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="WEBHOOK_NOT_FOUND",
            message=f"Webhook with ID {webhook_id} not found",
        )


@router.get(
    "/webhooks/{webhook_id}/deliveries",
    response_model=StandardListResponse[WebhookDeliveryResponse],
    status_code=status.HTTP_200_OK,
    summary="Get webhook deliveries",
    description="Get deliveries for a webhook. Requires integrations.view permission.",
)
async def get_webhook_deliveries(
    webhook_id: Annotated[UUID, Path(..., description="Webhook ID")],
    current_user: Annotated[User, Depends(require_permission("integrations.view"))],
    service: Annotated[IntegrationService, Depends(get_integration_service)],
    page: int = Query(default=1, ge=1, description="Page number"),
    page_size: int = Query(default=20, ge=1, le=100, description="Page size"),
    status: str | None = Query(None, description="Filter by delivery status"),
) -> StandardListResponse[WebhookDeliveryResponse]:
    """Get deliveries for a webhook."""
    from app.repositories.integration_repository import IntegrationRepository

    repository = IntegrationRepository(service.db)
    skip = (page - 1) * page_size
    deliveries = repository.get_deliveries_by_webhook(
        webhook_id, current_user.tenant_id, status, skip, page_size
    )
    total = len(deliveries)  # TODO: Add count method to repository

    total_pages = (total + page_size - 1) // page_size if total > 0 else 0

    return StandardListResponse(
        data=[WebhookDeliveryResponse.model_validate(d) for d in deliveries],
        total=total,
        page=page,
        page_size=page_size,
        total_pages=total_pages,
        message="Webhook deliveries retrieved successfully",
    )





"""Notifications router for notification management."""

import asyncio
import json
import logging
from typing import Annotated
from uuid import UUID

from fastapi import APIRouter, Depends, Path, Query, status
from fastapi.responses import StreamingResponse
from sqlalchemy.orm import Session

logger = logging.getLogger(__name__)

from app.core.auth.dependencies import require_permission
from app.core.db.deps import get_db
from app.core.exceptions import APIException
from app.core.notifications.service import NotificationService
from app.models.user import User
from app.repositories.notification_repository import NotificationRepository
from app.schemas.common import StandardListResponse, StandardResponse
from app.schemas.notification import (
    NotificationQueueResponse,
    NotificationSendRequest,
    NotificationTemplateCreate,
    NotificationTemplateResponse,
    NotificationTemplateUpdate,
)

router = APIRouter()


def get_notification_service(
    db: Annotated[Session, Depends(get_db)],
) -> NotificationService:
    """Dependency to get NotificationService."""
    return NotificationService(db)


def get_notification_repository(
    db: Annotated[Session, Depends(get_db)],
) -> NotificationRepository:
    """Dependency to get NotificationRepository."""
    return NotificationRepository(db)


@router.post(
    "/templates",
    response_model=StandardResponse[NotificationTemplateResponse],
    status_code=status.HTTP_201_CREATED,
    summary="Create notification template",
    description="Create a new notification template. Requires notifications.manage permission.",
)
async def create_template(
    template_data: NotificationTemplateCreate,
    current_user: Annotated[User, Depends(require_permission("notifications.manage"))],
    repository: Annotated[NotificationRepository, Depends(get_notification_repository)],
) -> StandardResponse[NotificationTemplateResponse]:
    """Create a new notification template."""
    template = repository.create_template(
        {
            "tenant_id": current_user.tenant_id,
            "name": template_data.name,
            "event_type": template_data.event_type,
            "channel": template_data.channel,
            "subject": template_data.subject,
            "body": template_data.body,
            "is_active": template_data.is_active,
        }
    )

    return StandardResponse(
        data=NotificationTemplateResponse.model_validate(template),
        message="Template created successfully",
    )


@router.get(
    "/templates",
    response_model=StandardListResponse[NotificationTemplateResponse],
    status_code=status.HTTP_200_OK,
    summary="List notification templates",
    description="List all notification templates for the current tenant. Requires notifications.view permission.",
)
async def list_templates(
    current_user: Annotated[User, Depends(require_permission("notifications.view"))],
    repository: Annotated[NotificationRepository, Depends(get_notification_repository)],
    page: int = Query(default=1, ge=1, description="Page number"),
    page_size: int = Query(default=20, ge=1, le=100, description="Page size"),
    event_type: str | None = Query(default=None, description="Filter by event type"),
) -> StandardListResponse[NotificationTemplateResponse]:
    """List all notification templates."""
    skip = (page - 1) * page_size
    templates = repository.get_all_templates(
        tenant_id=current_user.tenant_id, event_type=event_type
    )

    total = len(templates)
    total_pages = (total + page_size - 1) // page_size if total > 0 else 0

    # Apply pagination
    paginated_templates = templates[skip : skip + page_size]

    return StandardListResponse(
        data=[NotificationTemplateResponse.model_validate(t) for t in paginated_templates],
        total=total,
        page=page,
        page_size=page_size,
        total_pages=total_pages,
        message="Templates retrieved successfully",
    )


@router.get(
    "/templates/{template_id}",
    response_model=StandardResponse[NotificationTemplateResponse],
    status_code=status.HTTP_200_OK,
    summary="Get notification template",
    description="Get a specific notification template by ID. Requires notifications.view permission.",
)
async def get_template(
    template_id: UUID,
    current_user: Annotated[User, Depends(require_permission("notifications.view"))],
    repository: Annotated[NotificationRepository, Depends(get_notification_repository)],
) -> StandardResponse[NotificationTemplateResponse]:
    """Get a specific notification template."""
    # Get all templates and filter by ID and tenant
    templates = repository.get_all_templates(tenant_id=current_user.tenant_id)
    template = next((t for t in templates if t.id == template_id), None)

    if not template:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="NOTIFICATION_TEMPLATE_NOT_FOUND",
            message=f"Template with ID {template_id} not found",
        )

    return StandardResponse(
        data=NotificationTemplateResponse.model_validate(template),
        message="Template retrieved successfully",
    )


@router.put(
    "/templates/{template_id}",
    response_model=StandardResponse[NotificationTemplateResponse],
    status_code=status.HTTP_200_OK,
    summary="Update notification template",
    description="Update a notification template. Requires notifications.manage permission.",
)
async def update_template(
    template_id: UUID,
    template_data: NotificationTemplateUpdate,
    current_user: Annotated[User, Depends(require_permission("notifications.manage"))],
    repository: Annotated[NotificationRepository, Depends(get_notification_repository)],
) -> StandardResponse[NotificationTemplateResponse]:
    """Update a notification template."""
    # Build update dict with only provided fields
    update_dict = template_data.model_dump(exclude_unset=True)

    template = repository.update_template(template_id, current_user.tenant_id, update_dict)

    if not template:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="NOTIFICATION_TEMPLATE_NOT_FOUND",
            message=f"Template with ID {template_id} not found",
        )

    return StandardResponse(
        data=NotificationTemplateResponse.model_validate(template),
        message="Template updated successfully",
    )


@router.delete(
    "/templates/{template_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Delete notification template",
    description="Delete a notification template. Requires notifications.manage permission.",
)
async def delete_template(
    template_id: UUID,
    current_user: Annotated[User, Depends(require_permission("notifications.manage"))],
    repository: Annotated[NotificationRepository, Depends(get_notification_repository)],
) -> None:
    """Delete a notification template."""
    deleted = repository.delete_template(template_id, current_user.tenant_id)
    if not deleted:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="NOTIFICATION_TEMPLATE_NOT_FOUND",
            message=f"Template with ID {template_id} not found",
        )


@router.post(
    "/send",
    response_model=StandardResponse[list[dict]],
    status_code=status.HTTP_200_OK,
    summary="Send notification manually",
    description="Send a notification manually. Requires notifications.manage permission.",
)
async def send_notification(
    request: NotificationSendRequest,
    current_user: Annotated[User, Depends(require_permission("notifications.manage"))],
    service: Annotated[NotificationService, Depends(get_notification_service)],
) -> StandardResponse[list[dict]]:
    """Send a notification manually."""
    results = await service.send(
        event_type=request.event_type,
        recipient_id=request.recipient_id,
        channels=request.channels,
        data=request.data,
        tenant_id=current_user.tenant_id,
    )

    return StandardResponse(
        data=results,
        message="Notification sent successfully",
    )


@router.get(
    "/queue",
    response_model=StandardListResponse[NotificationQueueResponse],
    status_code=status.HTTP_200_OK,
    summary="List notification queue entries",
    description="List notification queue entries for the current tenant. Requires notifications.view permission.",
)
async def list_queue_entries(
    current_user: Annotated[User, Depends(require_permission("notifications.view"))],
    repository: Annotated[NotificationRepository, Depends(get_notification_repository)],
    page: int = Query(default=1, ge=1, description="Page number"),
    page_size: int = Query(default=20, ge=1, le=100, description="Page size"),
    status: str | None = Query(default=None, description="Filter by status (pending, sent, failed)"),
) -> StandardListResponse[NotificationQueueResponse]:
    """List notification queue entries."""
    skip = (page - 1) * page_size
    queue_entries = repository.get_queue_entries(
        tenant_id=current_user.tenant_id, status=status, skip=skip, limit=page_size
    )

    # TODO: Add count method to repository for accurate total
    total = len(queue_entries)
    total_pages = (total + page_size - 1) // page_size if total > 0 else 0

    return StandardListResponse(
        data=[NotificationQueueResponse.model_validate(entry) for entry in queue_entries],
        total=total,
        page=page,
        page_size=page_size,
        total_pages=total_pages,
        message="Queue entries retrieved successfully",
    )


@router.get(
    "/queue/{queue_id}",
    response_model=StandardResponse[NotificationQueueResponse],
    status_code=status.HTTP_200_OK,
    summary="Get notification queue entry",
    description="Get a specific notification queue entry by ID. Requires notifications.view permission.",
)
async def get_queue_entry(
    queue_id: Annotated[UUID, Path(..., description="Queue entry ID")],
    current_user: Annotated[User, Depends(require_permission("notifications.view"))],
    repository: Annotated[NotificationRepository, Depends(get_notification_repository)],
) -> StandardResponse[NotificationQueueResponse]:
    """Get a specific notification queue entry."""
    entry = repository.get_queue_entry_by_id(queue_id, current_user.tenant_id)

    if not entry:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="NOTIFICATION_QUEUE_ENTRY_NOT_FOUND",
            message=f"Queue entry with ID {queue_id} not found",
        )

    return StandardResponse(
        data=NotificationQueueResponse.model_validate(entry),
        message="Queue entry retrieved successfully",
    )


@router.get(
    "/stream",
    summary="Stream notifications (SSE)",
    description="Stream notifications in real-time using Server-Sent Events. Requires notifications.view permission.",
    responses={
        200: {
            "description": "Server-Sent Events stream",
            "content": {"text/event-stream": {}},
        },
    },
)
async def stream_notifications(
    current_user: Annotated[User, Depends(require_permission("notifications.view"))],
    repository: Annotated[NotificationRepository, Depends(get_notification_repository)],
) -> StreamingResponse:
    """Stream notifications using Server-Sent Events.

    This endpoint provides real-time notifications using SSE. The client will receive
    new notifications as they are created. The stream checks for new notifications
    every 5 seconds.

    Example client usage:
        const eventSource = new EventSource('/api/v1/notifications/stream', {
            headers: { 'Authorization': `Bearer ${token}` }
        });
        eventSource.onmessage = (event) => {
            const notification = JSON.parse(event.data);
            // Handle notification
        };
    """
    async def event_generator():
        """Generate SSE events for new notifications."""
        last_id = None
        try:
            while True:
                # Get new notifications
                new_notifications = repository.get_unread_notifications(
                    tenant_id=current_user.tenant_id,
                    user_id=current_user.id,
                    since_id=last_id,
                    limit=50,
                )

                # Send each notification as an SSE event
                for notification in new_notifications:
                    notification_data = NotificationQueueResponse.model_validate(
                        notification
                    ).model_dump()
                    # Format as SSE: "data: {json}\n\n"
                    yield f"data: {json.dumps(notification_data)}\n\n"
                    last_id = notification.id

                # Wait before next check (5 seconds)
                await asyncio.sleep(5)

        except asyncio.CancelledError:
            # Client disconnected
            logger.info(f"SSE stream disconnected for user {current_user.id}")
            raise
        except Exception as e:
            logger.error(f"Error in SSE stream for user {current_user.id}: {e}", exc_info=True)
            # Send error event
            error_data = {
                "error": {
                    "code": "STREAM_ERROR",
                    "message": "Error in notification stream",
                }
            }
            yield f"data: {json.dumps(error_data)}\n\n"

    return StreamingResponse(
        event_generator(),
        media_type="text/event-stream",
        headers={
            "Cache-Control": "no-cache",
            "Connection": "keep-alive",
            "X-Accel-Buffering": "no",  # Disable buffering in Nginx
        },
    )


"""Preferences router for user personalization."""

from typing import Annotated, Any
from uuid import UUID

from fastapi import APIRouter, Depends, Path, Query, status
from sqlalchemy.orm import Session

from app.core.auth.dependencies import require_permission
from app.core.db.deps import get_db
from app.core.exceptions import APIException
from app.core.preferences.dashboards import DashboardsService
from app.core.preferences.service import PreferencesService
from app.core.preferences.views import ViewsService
from app.models.user import User
from app.schemas.common import StandardListResponse, StandardResponse
from app.schemas.preference import (
    DashboardCreate,
    DashboardResponse,
    DashboardUpdate,
    NotificationPreferencesRequest,
    NotificationPreferenceSchema,
    PreferenceSetRequest,
    SavedViewCreate,
    SavedViewResponse,
    SavedViewUpdate,
)

router = APIRouter()


def get_preferences_service(
    db: Annotated[Session, Depends(get_db)],
) -> PreferencesService:
    """Dependency to get PreferencesService."""
    return PreferencesService(db)


def get_views_service(db: Annotated[Session, Depends(get_db)]) -> ViewsService:
    """Dependency to get ViewsService."""
    return ViewsService(db)


def get_dashboards_service(
    db: Annotated[Session, Depends(get_db)],
) -> DashboardsService:
    """Dependency to get DashboardsService."""
    return DashboardsService(db)


@router.get(
    "",
    response_model=StandardResponse[dict[str, Any]],
    status_code=status.HTTP_200_OK,
    summary="Get user preferences",
    description="Get all preferences for the current user with inheritance. Requires preferences.view permission.",
)
async def get_preferences(
    current_user: Annotated[User, Depends(require_permission("preferences.view"))],
    service: Annotated[PreferencesService, Depends(get_preferences_service)],
    preference_type: str | None = Query(None, description="Filter by preference type"),
) -> StandardResponse[dict[str, Any]]:
    """Get all preferences for the current user."""
    preferences = service.get_all_preferences(
        user_id=current_user.id,
        tenant_id=current_user.tenant_id,
        preference_type=preference_type,
    )
    return StandardResponse(
        data=preferences,
        message="Preferences retrieved successfully",
    )


@router.put(
    "",
    response_model=StandardResponse[dict[str, Any]],
    status_code=status.HTTP_200_OK,
    summary="Update user preferences",
    description="Update preferences for the current user. Requires preferences.manage permission.",
)
async def update_preferences(
    preference_data: PreferenceSetRequest,
    current_user: Annotated[User, Depends(require_permission("preferences.manage"))],
    service: Annotated[PreferencesService, Depends(get_preferences_service)],
    preference_type: str = Query(..., description="Preference type (e.g., 'basic', 'notification')"),
) -> StandardResponse[dict[str, Any]]:
    """Update preferences for the current user."""
    updated = {}
    for key, value in preference_data.preferences.items():
        result = service.set_preference(
            user_id=current_user.id,
            tenant_id=current_user.tenant_id,
            preference_type=preference_type,
            key=key,
            value=value,
        )
        updated[key] = result["value"]

    return StandardResponse(
        data=updated,
        message="Preferences updated successfully",
    )


@router.get(
    "/org",
    response_model=StandardResponse[dict[str, Any]],
    status_code=status.HTTP_200_OK,
    summary="Get organization preferences",
    description="Get organization preferences. Requires preferences.view permission.",
)
async def get_org_preferences(
    current_user: Annotated[User, Depends(require_permission("preferences.view"))],
    db: Annotated[Session, Depends(get_db)],
    preference_type: str | None = Query(None, description="Filter by preference type"),
) -> StandardResponse[dict[str, Any]]:
    """Get organization preferences."""
    from app.repositories.preference_repository import PreferenceRepository

    repository = PreferenceRepository(db)
    org_prefs = repository.get_all_org_preferences(
        current_user.tenant_id, preference_type
    )
    preferences = {pref.key: pref.value for pref in org_prefs}

    return StandardResponse(
        data=preferences,
        message="Organization preferences retrieved successfully",
    )


@router.put(
    "/org",
    response_model=StandardResponse[dict[str, Any]],
    status_code=status.HTTP_200_OK,
    summary="Update organization preferences",
    description="Update organization preferences. Requires preferences.manage permission.",
)
async def update_org_preferences(
    preference_data: PreferenceSetRequest,
    current_user: Annotated[User, Depends(require_permission("preferences.manage"))],
    service: Annotated[PreferencesService, Depends(get_preferences_service)],
    preference_type: str = Query(..., description="Preference type"),
) -> StandardResponse[dict[str, Any]]:
    """Update organization preferences."""
    updated = {}
    for key, value in preference_data.preferences.items():
        result = service.set_org_preference(
            tenant_id=current_user.tenant_id,
            preference_type=preference_type,
            key=key,
            value=value,
        )
        updated[key] = result["value"]

    return StandardResponse(
        data=updated,
        message="Organization preferences updated successfully",
    )


@router.get(
    "/notifications",
    response_model=StandardResponse[dict[str, NotificationPreferenceSchema]],
    status_code=status.HTTP_200_OK,
    summary="Get notification preferences",
    description="Get notification preferences for the current user. Requires preferences.view permission.",
)
async def get_notification_preferences(
    current_user: Annotated[User, Depends(require_permission("preferences.view"))],
    service: Annotated[PreferencesService, Depends(get_preferences_service)],
) -> StandardResponse[dict[str, NotificationPreferenceSchema]]:
    """Get notification preferences."""
    all_prefs = service.get_all_preferences(
        user_id=current_user.id,
        tenant_id=current_user.tenant_id,
        preference_type="notification",
    )

    # Convert to NotificationPreferenceSchema format
    notification_prefs = {}
    for key, value in all_prefs.items():
        if isinstance(value, dict):
            notification_prefs[key] = NotificationPreferenceSchema(**value)
        else:
            notification_prefs[key] = NotificationPreferenceSchema()

    return StandardResponse(
        data=notification_prefs,
        message="Notification preferences retrieved successfully",
    )


@router.put(
    "/notifications",
    response_model=StandardResponse[dict[str, Any]],
    status_code=status.HTTP_200_OK,
    summary="Update notification preferences",
    description="Update notification preferences for the current user. Requires preferences.manage permission.",
)
async def update_notification_preferences(
    notification_data: NotificationPreferencesRequest,
    current_user: Annotated[User, Depends(require_permission("preferences.manage"))],
    service: Annotated[PreferencesService, Depends(get_preferences_service)],
) -> StandardResponse[dict[str, Any]]:
    """Update notification preferences."""
    updated = {}
    for event_type, pref_schema in notification_data.preferences.items():
        result = service.set_preference(
            user_id=current_user.id,
            tenant_id=current_user.tenant_id,
            preference_type="notification",
            key=event_type,
            value=pref_schema.model_dump(),
        )
        updated[event_type] = result["value"]

    return StandardResponse(
        data=updated,
        message="Notification preferences updated successfully",
    )


@router.get(
    "/views/{module}",
    response_model=StandardListResponse[SavedViewResponse],
    status_code=status.HTTP_200_OK,
    summary="Get saved views",
    description="Get saved views for a module. Requires preferences.view permission.",
)
async def get_saved_views(
    current_user: Annotated[User, Depends(require_permission("preferences.view"))],
    views_service: Annotated[ViewsService, Depends(get_views_service)],
    module: str = Path(..., description="Module name"),
) -> StandardListResponse[SavedViewResponse]:
    """Get saved views for a module."""
    views = views_service.get_views(
        user_id=current_user.id,
        tenant_id=current_user.tenant_id,
        module=module,
    )

    return StandardListResponse(
        data=[SavedViewResponse(**view) for view in views],
        total=len(views),
        page=1,
        page_size=len(views),
        total_pages=1,
        message="Saved views retrieved successfully",
    )


@router.post(
    "/views/{module}",
    response_model=StandardResponse[SavedViewResponse],
    status_code=status.HTTP_201_CREATED,
    summary="Save a view",
    description="Save a view for a module. Requires preferences.manage permission.",
)
async def save_view(
    current_user: Annotated[User, Depends(require_permission("preferences.manage"))],
    views_service: Annotated[ViewsService, Depends(get_views_service)],
    module: str = Path(..., description="Module name"),
    view_data: SavedViewCreate = ...,
) -> StandardResponse[SavedViewResponse]:
    """Save a view."""
    view = views_service.save_view(
        user_id=current_user.id,
        tenant_id=current_user.tenant_id,
        module=module,
        name=view_data.name,
        config=view_data.config,
        is_default=view_data.is_default,
    )

    return StandardResponse(
        data=SavedViewResponse(**view),
        message="View saved successfully",
    )


@router.get(
    "/dashboards",
    response_model=StandardListResponse[DashboardResponse],
    status_code=status.HTTP_200_OK,
    summary="Get dashboards",
    description="Get dashboards for the current user. Requires preferences.view permission.",
)
async def get_dashboards(
    current_user: Annotated[User, Depends(require_permission("preferences.view"))],
    dashboards_service: Annotated[DashboardsService, Depends(get_dashboards_service)],
) -> StandardListResponse[DashboardResponse]:
    """Get dashboards for the current user."""
    dashboards = dashboards_service.get_dashboards(
        user_id=current_user.id, tenant_id=current_user.tenant_id
    )

    return StandardListResponse(
        data=[DashboardResponse(**dashboard) for dashboard in dashboards],
        total=len(dashboards),
        page=1,
        page_size=len(dashboards),
        total_pages=1,
        message="Dashboards retrieved successfully",
    )


@router.post(
    "/dashboards",
    response_model=StandardResponse[DashboardResponse],
    status_code=status.HTTP_201_CREATED,
    summary="Create dashboard",
    description="Create a dashboard. Requires preferences.manage permission.",
)
async def create_dashboard(
    dashboard_data: DashboardCreate,
    current_user: Annotated[User, Depends(require_permission("preferences.manage"))],
    dashboards_service: Annotated[DashboardsService, Depends(get_dashboards_service)],
) -> StandardResponse[DashboardResponse]:
    """Create a dashboard."""
    dashboard = dashboards_service.create_dashboard(
        user_id=current_user.id,
        tenant_id=current_user.tenant_id,
        name=dashboard_data.name,
        widgets=dashboard_data.widgets,
        is_default=dashboard_data.is_default,
    )

    return StandardResponse(
        data=DashboardResponse(**dashboard),
        message="Dashboard created successfully",
    )


"""Pub-Sub administrative router for event bus management."""

from typing import Annotated, Any

from fastapi import APIRouter, Depends, Query, status
from sqlalchemy.orm import Session

from app.core.auth.dependencies import require_permission
from app.core.config_file import get_settings
from app.core.db.deps import get_db
from app.core.exceptions import APIException
from app.core.pubsub.client import RedisStreamsClient
from app.core.pubsub.errors import PubSubError
from app.models.user import User
from app.schemas.common import StandardListResponse, StandardResponse

router = APIRouter()
settings = get_settings()


def get_redis_client() -> RedisStreamsClient:
    """Dependency to get Redis client."""
    return RedisStreamsClient(redis_url=settings.REDIS_URL, password=settings.REDIS_PASSWORD)


@router.get(
    "/stats",
    response_model=StandardResponse[dict[str, Any]],
    status_code=status.HTTP_200_OK,
    summary="Get Pub-Sub statistics",
    description="Get statistics about streams, groups, and pending messages. Requires pubsub.view permission.",
    responses={
        200: {"description": "Statistics retrieved successfully"},
        403: {"description": "Insufficient permissions"},
    },
)
async def get_stats(
    current_user: Annotated[User, Depends(require_permission("pubsub.view"))],
    redis_client: Annotated[RedisStreamsClient, Depends(get_redis_client)],
) -> StandardResponse[dict[str, Any]]:
    """Get statistics about all streams."""
    try:
        stats = {
            "streams": {},
            "total_pending": 0,
        }

        # Get stats for each stream
        for stream_name in [
            settings.REDIS_STREAM_DOMAIN,
            settings.REDIS_STREAM_TECHNICAL,
            settings.REDIS_STREAM_FAILED,
        ]:
            try:
                stream_info = await redis_client.get_stream_info(stream_name)
                groups_info = []

                # Get groups for this stream
                try:
                    async with redis_client.connection() as client:
                        groups = await client.xinfo_groups(stream_name)
                        for group in groups:
                            group_name = group.get("name", "unknown")
                            try:
                                group_info = await redis_client.get_group_info(stream_name, group_name)
                                pending = await redis_client.get_pending_messages(
                                    stream_name, group_name, count=100
                                )
                                groups_info.append(
                                    {
                                        "name": group_name,
                                        "consumers": group_info.get("consumers", 0),
                                        "pending": group_info.get("pending", 0),
                                        "last_delivered_id": group_info.get("last-delivered-id", "0-0"),
                                        "pending_messages_count": len(pending),
                                    }
                                )
                                stats["total_pending"] += len(pending)
                            except PubSubError:
                                # Group might not exist, skip
                                pass
                except PubSubError:
                    # No groups or stream doesn't exist
                    pass

                stats["streams"][stream_name] = {
                    "length": stream_info.get("length", 0),
                    "groups": groups_info,
                    "first_entry_id": stream_info.get("first-entry", "0-0"),
                    "last_entry_id": stream_info.get("last-entry", "0-0"),
                }
            except PubSubError:
                # Stream doesn't exist yet
                stats["streams"][stream_name] = {
                    "length": 0,
                    "groups": [],
                    "first_entry_id": None,
                    "last_entry_id": None,
                }

        return StandardResponse(
            success=True,
            data=stats,
            message="Statistics retrieved successfully",
        )
    except Exception as e:
        raise APIException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            code="PUBSUB_STATS_ERROR",
            message=f"Failed to retrieve statistics: {str(e)}",
        ) from e


@router.get(
    "/failed",
    response_model=StandardListResponse[dict[str, Any]],
    status_code=status.HTTP_200_OK,
    summary="List failed events",
    description="List events that failed processing and were moved to the failed stream. Requires pubsub.view permission.",
    responses={
        200: {"description": "Failed events retrieved successfully"},
        403: {"description": "Insufficient permissions"},
    },
)
async def list_failed_events(
    current_user: Annotated[User, Depends(require_permission("pubsub.view"))],
    redis_client: Annotated[RedisStreamsClient, Depends(get_redis_client)],
    limit: int = Query(default=50, ge=1, le=100, description="Maximum number of events to return"),
    offset: int = Query(default=0, ge=0, description="Offset for pagination"),
) -> StandardListResponse[dict[str, Any]]:
    """List failed events from the failed stream."""
    try:
        async with redis_client.connection() as client:
            # Read from failed stream (most recent first)
            messages = await client.xrevrange(
                settings.REDIS_STREAM_FAILED,
                max="+",
                min="-",
                count=limit + offset,
            )

            # Apply offset
            if offset > 0:
                messages = messages[offset:]

            # Limit results
            messages = messages[:limit]

            failed_events = []
            for message_id, data in messages:
                event_data = dict(data)
                event_data["message_id"] = message_id
                failed_events.append(event_data)

            return StandardListResponse(
                success=True,
                data=failed_events,
                total=len(failed_events),
                message="Failed events retrieved successfully",
            )
    except PubSubError as e:
        # Stream might not exist yet
        return StandardListResponse(
            success=True,
            data=[],
            total=0,
            message="No failed events found",
        )
    except Exception as e:
        raise APIException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            code="PUBSUB_FAILED_EVENTS_ERROR",
            message=f"Failed to retrieve failed events: {str(e)}",
        ) from e


@router.post(
    "/failed/{message_id}/reprocess",
    response_model=StandardResponse[dict[str, Any]],
    status_code=status.HTTP_200_OK,
    summary="Reprocess failed event",
    description="Reprocess a failed event by moving it back to its original stream. Requires pubsub.manage permission.",
    responses={
        200: {"description": "Event reprocessed successfully"},
        404: {"description": "Event not found"},
        403: {"description": "Insufficient permissions"},
    },
)
async def reprocess_failed_event(
    message_id: str,
    current_user: Annotated[User, Depends(require_permission("pubsub.manage"))],
    redis_client: Annotated[RedisStreamsClient, Depends(get_redis_client)],
) -> StandardResponse[dict[str, Any]]:
    """Reprocess a failed event."""
    try:
        async with redis_client.connection() as client:
            # Read the failed event
            messages = await client.xrange(
                settings.REDIS_STREAM_FAILED,
                min=message_id,
                max=message_id,
                count=1,
            )

            if not messages:
                raise APIException(
                    status_code=status.HTTP_404_NOT_FOUND,
                    code="PUBSUB_EVENT_NOT_FOUND",
                    message=f"Failed event with ID {message_id} not found",
                )

            _, event_data = messages[0]
            original_stream = event_data.get("original_stream")
            if not original_stream:
                raise APIException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    code="PUBSUB_INVALID_EVENT",
                    message="Event does not have original_stream information",
                )

            # Remove error fields and restore original event data
            reprocess_data = {
                k: v
                for k, v in event_data.items()
                if k not in ["original_stream", "original_message_id", "error_info", "failed_at"]
            }

            # Add back to original stream
            new_message_id = await client.xadd(original_stream, reprocess_data)

            # Remove from failed stream
            await client.xdel(settings.REDIS_STREAM_FAILED, message_id)

            return StandardResponse(
                success=True,
                data={
                    "original_message_id": message_id,
                    "new_message_id": new_message_id,
                    "original_stream": original_stream,
                },
                message="Event reprocessed successfully",
            )
    except APIException:
        raise
    except Exception as e:
        raise APIException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            code="PUBSUB_REPROCESS_ERROR",
            message=f"Failed to reprocess event: {str(e)}",
        ) from e


@router.get(
    "/streams/{stream_name}/info",
    response_model=StandardResponse[dict[str, Any]],
    status_code=status.HTTP_200_OK,
    summary="Get stream information",
    description="Get detailed information about a specific stream. Requires pubsub.view permission.",
    responses={
        200: {"description": "Stream information retrieved successfully"},
        404: {"description": "Stream not found"},
        403: {"description": "Insufficient permissions"},
    },
)
async def get_stream_info(
    stream_name: str,
    current_user: Annotated[User, Depends(require_permission("pubsub.view"))],
    redis_client: Annotated[RedisStreamsClient, Depends(get_redis_client)],
) -> StandardResponse[dict[str, Any]]:
    """Get detailed information about a stream."""
    try:
        stream_info = await redis_client.get_stream_info(stream_name)

        # Get groups
        groups = []
        try:
            async with redis_client.connection() as client:
                groups_data = await client.xinfo_groups(stream_name)
                for group in groups_data:
                    group_name = group.get("name", "unknown")
                    try:
                        group_info = await redis_client.get_group_info(stream_name, group_name)
                        groups.append(dict(group_info))
                    except PubSubError:
                        pass
        except PubSubError:
            pass

        return StandardResponse(
            success=True,
            data={
                "stream_name": stream_name,
                "length": stream_info.get("length", 0),
                "groups": groups,
                "first_entry_id": stream_info.get("first-entry", "0-0"),
                "last_entry_id": stream_info.get("last-entry", "0-0"),
            },
            message="Stream information retrieved successfully",
        )
    except PubSubError as e:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="PUBSUB_STREAM_NOT_FOUND",
            message=f"Stream '{stream_name}' not found: {str(e)}",
        ) from e
    except Exception as e:
        raise APIException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            code="PUBSUB_STREAM_INFO_ERROR",
            message=f"Failed to retrieve stream information: {str(e)}",
        ) from e


@router.get(
    "/streams/{stream_name}/groups/{group_name}/pending",
    response_model=StandardListResponse[dict[str, Any]],
    status_code=status.HTTP_200_OK,
    summary="Get pending messages for a group",
    description="Get pending messages for a specific consumer group. Requires pubsub.view permission.",
    responses={
        200: {"description": "Pending messages retrieved successfully"},
        404: {"description": "Stream or group not found"},
        403: {"description": "Insufficient permissions"},
    },
)
async def get_pending_messages(
    stream_name: str,
    group_name: str,
    current_user: Annotated[User, Depends(require_permission("pubsub.view"))],
    redis_client: Annotated[RedisStreamsClient, Depends(get_redis_client)],
    count: int = Query(default=10, ge=1, le=100, description="Maximum number of messages to return"),
) -> StandardListResponse[dict[str, Any]]:
    """Get pending messages for a consumer group."""
    try:
        pending = await redis_client.get_pending_messages(stream_name, group_name, count=count)

        return StandardListResponse(
            success=True,
            data=pending,
            total=len(pending),
            message="Pending messages retrieved successfully",
        )
    except PubSubError as e:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="PUBSUB_GROUP_NOT_FOUND",
            message=f"Stream or group not found: {str(e)}",
        ) from e
    except Exception as e:
        raise APIException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            code="PUBSUB_PENDING_ERROR",
            message=f"Failed to retrieve pending messages: {str(e)}",
        ) from e







"""Reporting router for report management."""

from typing import Annotated, Any
from uuid import UUID

from fastapi import APIRouter, Depends, Query, status
from sqlalchemy.orm import Session

from app.core.auth.dependencies import require_permission
from app.core.db.deps import get_db
from app.core.exceptions import APIException
from app.core.reporting.engine import ReportingEngine
from app.core.reporting.service import ReportingService
from app.core.reporting.sources.products_data_source import ProductsDataSource
from app.models.user import User
from app.schemas.common import StandardListResponse, StandardResponse
from app.schemas.reporting import (
    ReportDefinitionCreate,
    ReportDefinitionResponse,
    ReportDefinitionUpdate,
    ReportExecutionRequest,
    ReportExecutionResponse,
)

router = APIRouter()


def get_reporting_service(
    db: Annotated[Session, Depends(get_db)],
) -> ReportingService:
    """Dependency to get ReportingService."""
    service = ReportingService(db)
    # Register data sources
    service.engine.register_data_source("products", ProductsDataSource)
    return service


@router.post(
    "/reports",
    response_model=StandardResponse[ReportDefinitionResponse],
    status_code=status.HTTP_201_CREATED,
    summary="Create report",
    description="Create a new report definition. Requires reporting.manage permission.",
)
async def create_report(
    report_data: ReportDefinitionCreate,
    current_user: Annotated[User, Depends(require_permission("reporting.manage"))],
    service: Annotated[ReportingService, Depends(get_reporting_service)],
) -> StandardResponse[ReportDefinitionResponse]:
    """Create a new report definition."""
    report = service.create_report(
        tenant_id=current_user.tenant_id,
        name=report_data.name,
        description=report_data.description,
        data_source_type=report_data.data_source_type,
        visualization_type=report_data.visualization_type,
        created_by=current_user.id,
        filters=report_data.filters,
        config=report_data.config,
    )

    return StandardResponse(
        data=ReportDefinitionResponse.model_validate(report),
        message="Report created successfully",
    )


@router.get(
    "/reports",
    response_model=StandardListResponse[ReportDefinitionResponse],
    status_code=status.HTTP_200_OK,
    summary="List reports",
    description="List all reports for the current tenant. Requires reporting.view permission.",
)
async def list_reports(
    current_user: Annotated[User, Depends(require_permission("reporting.view"))],
    service: Annotated[ReportingService, Depends(get_reporting_service)],
    page: int = Query(default=1, ge=1, description="Page number"),
    page_size: int = Query(default=20, ge=1, le=100, description="Page size"),
) -> StandardListResponse[ReportDefinitionResponse]:
    """List all reports."""
    skip = (page - 1) * page_size
    reports = service.get_all_reports(
        tenant_id=current_user.tenant_id, skip=skip, limit=page_size
    )

    total = len(reports)  # TODO: Add count method to repository
    total_pages = (total + page_size - 1) // page_size if total > 0 else 0

    return StandardListResponse(
        data=[ReportDefinitionResponse.model_validate(report) for report in reports],
        total=total,
        page=page,
        page_size=page_size,
        total_pages=total_pages,
        message="Reports retrieved successfully",
    )


@router.get(
    "/reports/{report_id}",
    response_model=StandardResponse[ReportDefinitionResponse],
    status_code=status.HTTP_200_OK,
    summary="Get report",
    description="Get a specific report by ID. Requires reporting.view permission.",
)
async def get_report(
    report_id: UUID,
    current_user: Annotated[User, Depends(require_permission("reporting.view"))],
    service: Annotated[ReportingService, Depends(get_reporting_service)],
) -> StandardResponse[ReportDefinitionResponse]:
    """Get a specific report."""
    report = service.get_report(report_id, current_user.tenant_id)
    if not report:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="REPORTING_REPORT_NOT_FOUND",
            message=f"Report with ID {report_id} not found",
        )

    return StandardResponse(
        data=ReportDefinitionResponse.model_validate(report),
        message="Report retrieved successfully",
    )


@router.put(
    "/reports/{report_id}",
    response_model=StandardResponse[ReportDefinitionResponse],
    status_code=status.HTTP_200_OK,
    summary="Update report",
    description="Update a report definition. Requires reporting.manage permission.",
)
async def update_report(
    report_id: UUID,
    report_data: ReportDefinitionUpdate,
    current_user: Annotated[User, Depends(require_permission("reporting.manage"))],
    service: Annotated[ReportingService, Depends(get_reporting_service)],
) -> StandardResponse[ReportDefinitionResponse]:
    """Update a report definition."""
    report = service.update_report(
        report_id=report_id,
        tenant_id=current_user.tenant_id,
        name=report_data.name,
        description=report_data.description,
        filters=report_data.filters,
        config=report_data.config,
    )

    if not report:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="REPORTING_REPORT_NOT_FOUND",
            message=f"Report with ID {report_id} not found",
        )

    return StandardResponse(
        data=ReportDefinitionResponse.model_validate(report),
        message="Report updated successfully",
    )


@router.delete(
    "/reports/{report_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Delete report",
    description="Delete a report definition. Requires reporting.manage permission.",
)
async def delete_report(
    report_id: UUID,
    current_user: Annotated[User, Depends(require_permission("reporting.manage"))],
    service: Annotated[ReportingService, Depends(get_reporting_service)],
) -> None:
    """Delete a report definition."""
    deleted = service.delete_report(report_id, current_user.tenant_id)
    if not deleted:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="REPORTING_REPORT_NOT_FOUND",
            message=f"Report with ID {report_id} not found",
        )


@router.post(
    "/reports/{report_id}/execute",
    response_model=StandardResponse[ReportExecutionResponse],
    status_code=status.HTTP_200_OK,
    summary="Execute report",
    description="Execute a report and get results. Requires reporting.view permission.",
)
async def execute_report(
    report_id: UUID,
    execution_data: ReportExecutionRequest,
    current_user: Annotated[User, Depends(require_permission("reporting.view"))],
    service: Annotated[ReportingService, Depends(get_reporting_service)],
) -> StandardResponse[ReportExecutionResponse]:
    """Execute a report."""
    try:
        result = await service.execute_report(
            report_id=report_id,
            tenant_id=current_user.tenant_id,
            filters=execution_data.filters,
            pagination=execution_data.pagination,
        )
        return StandardResponse(
            data=ReportExecutionResponse(**result),
            message="Report executed successfully",
        )
    except ValueError as e:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="REPORTING_REPORT_NOT_FOUND",
            message=str(e),
        )


@router.get(
    "/data-sources",
    response_model=StandardResponse[list[dict[str, Any]]],
    status_code=status.HTTP_200_OK,
    summary="List data sources",
    description="List available data sources. Requires reporting.view permission.",
)
async def list_data_sources(
    current_user: Annotated[User, Depends(require_permission("reporting.view"))],
    service: Annotated[ReportingService, Depends(get_reporting_service)],
) -> StandardResponse[list[dict[str, Any]]]:
    """List available data sources."""
    # Return registered data sources
    data_sources = [
        {"type": source_type, "name": source_type.capitalize()}
        for source_type in service.engine._data_sources.keys()
    ]

    return StandardResponse(
        data=data_sources,
        message="Data sources retrieved successfully",
    )


@router.get(
    "/data-sources/{source_type}/columns",
    response_model=StandardResponse[list[dict[str, Any]]],
    status_code=status.HTTP_200_OK,
    summary="Get data source columns",
    description="Get available columns for a data source. Requires reporting.view permission.",
)
async def get_data_source_columns(
    source_type: str,
    current_user: Annotated[User, Depends(require_permission("reporting.view"))],
    service: Annotated[ReportingService, Depends(get_reporting_service)],
    db: Annotated[Session, Depends(get_db)],
) -> StandardResponse[list[dict[str, Any]]]:
    """Get columns for a data source."""
    data_source_class = service.engine._data_sources.get(source_type)
    if not data_source_class:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="REPORTING_DATA_SOURCE_NOT_FOUND",
            message=f"Data source type '{source_type}' not found",
        )

    # Create temporary instance to get columns
    data_source = data_source_class(db, current_user.tenant_id)
    columns = data_source.get_columns()

    return StandardResponse(
        data=columns,
        message="Columns retrieved successfully",
    )


@router.get(
    "/data-sources/{source_type}/filters",
    response_model=StandardResponse[list[dict[str, Any]]],
    status_code=status.HTTP_200_OK,
    summary="Get data source filters",
    description="Get available filters for a data source. Requires reporting.view permission.",
)
async def get_data_source_filters(
    source_type: str,
    current_user: Annotated[User, Depends(require_permission("reporting.view"))],
    service: Annotated[ReportingService, Depends(get_reporting_service)],
    db: Annotated[Session, Depends(get_db)],
) -> StandardResponse[list[dict[str, Any]]]:
    """Get filters for a data source."""
    data_source_class = service.engine._data_sources.get(source_type)
    if not data_source_class:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="REPORTING_DATA_SOURCE_NOT_FOUND",
            message=f"Data source type '{source_type}' not found",
        )

    # Create temporary instance to get filters
    data_source = data_source_class(db, current_user.tenant_id)
    filters = data_source.get_filters()

    return StandardResponse(
        data=filters,
        message="Filters retrieved successfully",
    )


"""Search router for global search functionality."""

from typing import Annotated
from uuid import UUID

from fastapi import APIRouter, Depends, Path, Query, status
from sqlalchemy.orm import Session

from app.core.auth.dependencies import require_permission
from app.core.db.deps import get_db
from app.core.search.engine import SearchEngine
from app.core.search.indexer import SearchIndexer
from app.models.user import User
from app.schemas.common import StandardResponse
from app.schemas.search import (
    IndexEntityRequest,
    SearchRequest,
    SearchResponse,
    SearchSuggestion,
)

router = APIRouter()


def get_search_engine(db: Annotated[Session, Depends(get_db)]) -> SearchEngine:
    """Dependency to get SearchEngine."""
    return SearchEngine(db)


def get_search_indexer(db: Annotated[Session, Depends(get_db)]) -> SearchIndexer:
    """Dependency to get SearchIndexer."""
    return SearchIndexer(db)


@router.post(
    "",
    response_model=StandardResponse[SearchResponse],
    status_code=status.HTTP_200_OK,
    summary="Global search",
    description="Search across all indexed entities. Requires search.view permission.",
)
async def search(
    search_request: SearchRequest,
    current_user: Annotated[User, Depends(require_permission("search.view"))],
    engine: Annotated[SearchEngine, Depends(get_search_engine)],
) -> StandardResponse[SearchResponse]:
    """Search across all indexed entities."""
    results = engine.search(
        tenant_id=current_user.tenant_id,
        query=search_request.query,
        entity_types=search_request.entity_types,
        limit=search_request.limit,
    )

    return StandardResponse(
        data=SearchResponse.model_validate(results),
        message="Search completed successfully",
    )


@router.get(
    "/suggestions",
    response_model=StandardResponse[list[SearchSuggestion]],
    status_code=status.HTTP_200_OK,
    summary="Get search suggestions",
    description="Get search suggestions. Requires search.view permission.",
)
async def get_suggestions(
    current_user: Annotated[User, Depends(require_permission("search.view"))],
    engine: Annotated[SearchEngine, Depends(get_search_engine)],
    query: Annotated[str, Query(..., description="Search query", min_length=1)],
    limit: int = Query(default=10, ge=1, le=50, description="Maximum number of suggestions"),
) -> StandardResponse[list[SearchSuggestion]]:
    """Get search suggestions."""
    suggestions = engine.get_suggestions(
        tenant_id=current_user.tenant_id,
        query=query,
        limit=limit,
    )

    return StandardResponse(
        data=[SearchSuggestion.model_validate(s) for s in suggestions],
        message="Suggestions retrieved successfully",
    )


@router.post(
    "/index",
    status_code=status.HTTP_201_CREATED,
    summary="Index entity",
    description="Index an entity for search. Requires search.manage permission.",
)
async def index_entity(
    index_request: IndexEntityRequest,
    current_user: Annotated[User, Depends(require_permission("search.manage"))],
    indexer: Annotated[SearchIndexer, Depends(get_search_indexer)],
) -> StandardResponse[dict]:
    """Index an entity for search."""
    index = indexer.index_entity(
        entity_type=index_request.entity_type,
        entity_id=index_request.entity_id,
        tenant_id=current_user.tenant_id,
        title=index_request.title,
        content=index_request.content,
        metadata=index_request.metadata,
    )

    return StandardResponse(
        data={"id": str(index.id), "entity_type": index.entity_type, "entity_id": str(index.entity_id)},
        message="Entity indexed successfully",
    )


@router.delete(
    "/index/{entity_type}/{entity_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Remove entity from index",
    description="Remove an entity from search index. Requires search.manage permission.",
)
async def remove_index(
    entity_type: Annotated[str, Path(..., description="Entity type")],
    entity_id: Annotated[UUID, Path(..., description="Entity ID")],
    current_user: Annotated[User, Depends(require_permission("search.manage"))],
    indexer: Annotated[SearchIndexer, Depends(get_search_indexer)],
) -> None:
    """Remove an entity from search index."""
    deleted = indexer.remove_index(entity_type, entity_id, current_user.tenant_id)
    if not deleted:
        from app.core.exceptions import APIException

        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="INDEX_NOT_FOUND",
            message=f"Index for {entity_type}:{entity_id} not found",
        )


"""Tags router for tag management."""

from typing import Annotated
from uuid import UUID

from fastapi import APIRouter, Depends, Path, Query, status
from sqlalchemy.orm import Session

from app.core.auth.dependencies import require_permission
from app.core.db.deps import get_db
from app.core.exceptions import APIException
from app.core.tags.service import TagService
from app.models.user import User
from app.schemas.common import StandardListResponse, StandardResponse
from app.schemas.tag import (
    TagCategoryCreate,
    TagCategoryResponse,
    TagCreate,
    TagResponse,
    TagUpdate,
)

router = APIRouter()


def get_tag_service(db: Annotated[Session, Depends(get_db)]) -> TagService:
    """Dependency to get TagService."""
    return TagService(db)


@router.post(
    "",
    response_model=StandardResponse[TagResponse],
    status_code=status.HTTP_201_CREATED,
    summary="Create tag",
    description="Create a new tag. Requires tags.manage permission.",
)
async def create_tag(
    tag_data: TagCreate,
    current_user: Annotated[User, Depends(require_permission("tags.manage"))],
    service: Annotated[TagService, Depends(get_tag_service)],
) -> StandardResponse[TagResponse]:
    """Create a new tag."""
    tag = service.create_tag(
        name=tag_data.name,
        tenant_id=current_user.tenant_id,
        color=tag_data.color,
        description=tag_data.description,
        category_id=tag_data.category_id,
    )

    return StandardResponse(
        data=TagResponse.model_validate(tag),
        message="Tag created successfully",
    )


@router.get(
    "",
    response_model=StandardListResponse[TagResponse],
    status_code=status.HTTP_200_OK,
    summary="List tags",
    description="List all tags for the current tenant. Requires tags.view permission.",
)
async def list_tags(
    current_user: Annotated[User, Depends(require_permission("tags.view"))],
    service: Annotated[TagService, Depends(get_tag_service)],
    category_id: UUID | None = Query(default=None, description="Filter by category"),
    search: str | None = Query(default=None, description="Search by name"),
) -> StandardListResponse[TagResponse]:
    """List all tags."""
    if search:
        tags = service.search_tags(current_user.tenant_id, search)
        total = len(tags)
    else:
        tags = service.get_all_tags(current_user.tenant_id, category_id=category_id)
        total = len(tags)

    return StandardListResponse(
        data=[TagResponse.model_validate(t) for t in tags],
        meta={
            "total": total,
            "page": 1,
            "page_size": max(1, total) if total > 0 else 20,
            "total_pages": 1,
        },
        message="Tags retrieved successfully",
    )


@router.get(
    "/{tag_id}",
    response_model=StandardResponse[TagResponse],
    status_code=status.HTTP_200_OK,
    summary="Get tag",
    description="Get a specific tag by ID. Requires tags.view permission.",
)
async def get_tag(
    tag_id: Annotated[UUID, Path(..., description="Tag ID")],
    current_user: Annotated[User, Depends(require_permission("tags.view"))],
    service: Annotated[TagService, Depends(get_tag_service)],
) -> StandardResponse[TagResponse]:
    """Get a specific tag."""
    tag = service.repository.get_tag_by_id(tag_id, current_user.tenant_id)
    if not tag:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="TAG_NOT_FOUND",
            message=f"Tag with ID {tag_id} not found",
        )

    return StandardResponse(
        data=TagResponse.model_validate(tag),
        message="Tag retrieved successfully",
    )


@router.put(
    "/{tag_id}",
    response_model=StandardResponse[TagResponse],
    status_code=status.HTTP_200_OK,
    summary="Update tag",
    description="Update a tag. Requires tags.manage permission.",
)
async def update_tag(
    tag_id: Annotated[UUID, Path(..., description="Tag ID")],
    current_user: Annotated[User, Depends(require_permission("tags.manage"))],
    service: Annotated[TagService, Depends(get_tag_service)],
    tag_data: TagUpdate,
) -> StandardResponse[TagResponse]:
    """Update a tag."""
    tag = service.update_tag(
        tag_id=tag_id,
        tenant_id=current_user.tenant_id,
        name=tag_data.name,
        color=tag_data.color,
        description=tag_data.description,
        category_id=tag_data.category_id,
    )

    if not tag:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="TAG_NOT_FOUND",
            message=f"Tag with ID {tag_id} not found",
        )

    return StandardResponse(
        data=TagResponse.model_validate(tag),
        message="Tag updated successfully",
    )


@router.delete(
    "/{tag_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Delete tag",
    description="Delete a tag (soft delete). Requires tags.manage permission.",
)
async def delete_tag(
    tag_id: Annotated[UUID, Path(..., description="Tag ID")],
    current_user: Annotated[User, Depends(require_permission("tags.manage"))],
    service: Annotated[TagService, Depends(get_tag_service)],
) -> None:
    """Delete a tag."""
    deleted = service.delete_tag(tag_id, current_user.tenant_id)
    if not deleted:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="TAG_NOT_FOUND",
            message=f"Tag with ID {tag_id} not found",
        )


@router.post(
    "/{tag_id}/entities/{entity_type}/{entity_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Add tag to entity",
    description="Add a tag to an entity. Requires tags.manage permission.",
)
async def add_tag_to_entity(
    tag_id: Annotated[UUID, Path(..., description="Tag ID")],
    entity_type: Annotated[str, Path(..., description="Entity type")],
    entity_id: Annotated[UUID, Path(..., description="Entity ID")],
    current_user: Annotated[User, Depends(require_permission("tags.manage"))],
    service: Annotated[TagService, Depends(get_tag_service)],
) -> None:
    """Add a tag to an entity."""
    try:
        service.add_tag_to_entity(
            tag_id=tag_id,
            entity_type=entity_type,
            entity_id=entity_id,
            tenant_id=current_user.tenant_id,
        )
    except ValueError as e:
        raise APIException(
            status_code=status.HTTP_400_BAD_REQUEST,
            code="TAG_OPERATION_FAILED",
            message=str(e),
        )


@router.delete(
    "/{tag_id}/entities/{entity_type}/{entity_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Remove tag from entity",
    description="Remove a tag from an entity. Requires tags.manage permission.",
)
async def remove_tag_from_entity(
    tag_id: Annotated[UUID, Path(..., description="Tag ID")],
    entity_type: Annotated[str, Path(..., description="Entity type")],
    entity_id: Annotated[UUID, Path(..., description="Entity ID")],
    current_user: Annotated[User, Depends(require_permission("tags.manage"))],
    service: Annotated[TagService, Depends(get_tag_service)],
) -> None:
    """Remove a tag from an entity."""
    removed = service.remove_tag_from_entity(
        tag_id=tag_id,
        entity_type=entity_type,
        entity_id=entity_id,
        tenant_id=current_user.tenant_id,
    )
    if not removed:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="ENTITY_TAG_NOT_FOUND",
            message=f"Tag {tag_id} not found on entity {entity_type}:{entity_id}",
        )


@router.get(
    "/entities/{entity_type}/{entity_id}",
    response_model=StandardListResponse[TagResponse],
    status_code=status.HTTP_200_OK,
    summary="Get entity tags",
    description="Get all tags for an entity. Requires tags.view permission.",
)
async def get_entity_tags(
    entity_type: Annotated[str, Path(..., description="Entity type")],
    entity_id: Annotated[UUID, Path(..., description="Entity ID")],
    current_user: Annotated[User, Depends(require_permission("tags.view"))],
    service: Annotated[TagService, Depends(get_tag_service)],
) -> StandardListResponse[TagResponse]:
    """Get all tags for an entity."""
    tags = service.get_entity_tags(entity_type, entity_id, current_user.tenant_id)

    return StandardListResponse(
        data=[TagResponse.model_validate(t) for t in tags],
        meta={
            "total": len(tags),
            "page": 1,
            "page_size": max(1, len(tags)) if len(tags) > 0 else 20,
            "total_pages": 1,
        },
        message="Entity tags retrieved successfully",
    )


@router.get(
    "/categories",
    response_model=StandardListResponse[TagCategoryResponse],
    status_code=status.HTTP_200_OK,
    summary="List tag categories",
    description="List all tag categories. Requires tags.view permission.",
)
async def list_categories(
    current_user: Annotated[User, Depends(require_permission("tags.view"))],
    service: Annotated[TagService, Depends(get_tag_service)],
) -> StandardListResponse[TagCategoryResponse]:
    """List all tag categories."""
    categories = service.get_all_categories(current_user.tenant_id)

    return StandardListResponse(
        data=[TagCategoryResponse.model_validate(c) for c in categories],
        meta={
            "total": len(categories),
            "page": 1,
            "page_size": max(1, len(categories)) if len(categories) > 0 else 20,
            "total_pages": 1,
        },
        message="Tag categories retrieved successfully",
    )


@router.post(
    "/categories",
    response_model=StandardResponse[TagCategoryResponse],
    status_code=status.HTTP_201_CREATED,
    summary="Create tag category",
    description="Create a new tag category. Requires tags.manage permission.",
)
async def create_category(
    category_data: TagCategoryCreate,
    current_user: Annotated[User, Depends(require_permission("tags.manage"))],
    service: Annotated[TagService, Depends(get_tag_service)],
) -> StandardResponse[TagCategoryResponse]:
    """Create a new tag category."""
    category = service.create_category(
        name=category_data.name,
        tenant_id=current_user.tenant_id,
        color=category_data.color,
        description=category_data.description,
        parent_id=category_data.parent_id,
        sort_order=category_data.sort_order,
    )

    return StandardResponse(
        data=TagCategoryResponse.model_validate(category),
        message="Tag category created successfully",
    )


"""Tasks router for task management."""

from typing import Annotated
from uuid import UUID

from fastapi import APIRouter, Depends, Path, Query, status
from sqlalchemy.orm import Session

from app.core.auth.dependencies import require_permission
from app.core.db.deps import get_db
from app.core.exceptions import APIException
from app.core.tasks.service import TaskService
from app.core.tasks.workflow_service import WorkflowService
from app.models.user import User
from app.schemas.common import StandardListResponse, StandardResponse
from app.schemas.task import (
    TaskChecklistItemCreate,
    TaskChecklistItemResponse,
    TaskChecklistItemUpdate,
    TaskCreate,
    TaskResponse,
    TaskUpdate,
    WorkflowCreate,
    WorkflowExecutionCreate,
    WorkflowExecutionResponse,
    WorkflowResponse,
    WorkflowStepCreate,
    WorkflowStepResponse,
    WorkflowUpdate,
)

router = APIRouter()


def get_task_service(db: Annotated[Session, Depends(get_db)]) -> TaskService:
    """Dependency to get TaskService."""
    return TaskService(db)


def get_workflow_service(db: Annotated[Session, Depends(get_db)]) -> WorkflowService:
    """Dependency to get WorkflowService."""
    return WorkflowService(db)


# Task endpoints
@router.post(
    "",
    response_model=StandardResponse[TaskResponse],
    status_code=status.HTTP_201_CREATED,
    summary="Create task",
    description="Create a new task. Requires tasks.manage permission.",
)
async def create_task(
    task_data: TaskCreate,
    current_user: Annotated[User, Depends(require_permission("tasks.manage"))],
    service: Annotated[TaskService, Depends(get_task_service)],
) -> StandardResponse[TaskResponse]:
    """Create a new task."""
    task = service.create_task(
        title=task_data.title,
        tenant_id=current_user.tenant_id,
        created_by_id=current_user.id,
        description=task_data.description,
        status=task_data.status,
        priority=task_data.priority,
        assigned_to_id=task_data.assigned_to_id,
        due_date=task_data.due_date,
        related_entity_type=task_data.related_entity_type,
        related_entity_id=task_data.related_entity_id,
        metadata=task_data.metadata,
    )

    return StandardResponse(
        data=TaskResponse.model_validate(task),
        message="Task created successfully",
    )


@router.get(
    "",
    response_model=StandardListResponse[TaskResponse],
    status_code=status.HTTP_200_OK,
    summary="List tasks",
    description="List tasks with optional filters. Requires tasks.view permission.",
)
async def list_tasks(
    current_user: Annotated[User, Depends(require_permission("tasks.view"))],
    service: Annotated[TaskService, Depends(get_task_service)],
    page: int = Query(default=1, ge=1, description="Page number"),
    page_size: int = Query(default=20, ge=1, le=100, description="Page size"),
    status: str | None = Query(default=None, description="Filter by status"),
    priority: str | None = Query(default=None, description="Filter by priority"),
    assigned_to_id: UUID | None = Query(default=None, description="Filter by assigned user"),
) -> StandardListResponse[TaskResponse]:
    """List tasks."""
    skip = (page - 1) * page_size
    tasks = service.get_tasks(
        tenant_id=current_user.tenant_id,
        status=status,
        priority=priority,
        assigned_to_id=assigned_to_id,
        skip=skip,
        limit=page_size,
    )
    total = len(tasks)  # TODO: Add count method to repository

    total_pages = (total + page_size - 1) // page_size if total > 0 else 0

    return StandardListResponse(
        data=[TaskResponse.model_validate(t) for t in tasks],
        meta={
            "total": total,
            "page": page,
            "page_size": page_size,
            "total_pages": total_pages,
        },
        message="Tasks retrieved successfully",
    )


@router.get(
    "/{task_id}",
    response_model=StandardResponse[TaskResponse],
    status_code=status.HTTP_200_OK,
    summary="Get task",
    description="Get a specific task by ID. Requires tasks.view permission.",
)
async def get_task(
    task_id: Annotated[UUID, Path(..., description="Task ID")],
    current_user: Annotated[User, Depends(require_permission("tasks.view"))],
    service: Annotated[TaskService, Depends(get_task_service)],
) -> StandardResponse[TaskResponse]:
    """Get a specific task."""
    task = service.get_task(task_id, current_user.tenant_id)
    if not task:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="TASK_NOT_FOUND",
            message=f"Task with ID {task_id} not found",
        )

    return StandardResponse(
        data=TaskResponse.model_validate(task),
        message="Task retrieved successfully",
    )


@router.put(
    "/{task_id}",
    response_model=StandardResponse[TaskResponse],
    status_code=status.HTTP_200_OK,
    summary="Update task",
    description="Update a task. Requires tasks.manage permission.",
)
async def update_task(
    task_id: Annotated[UUID, Path(..., description="Task ID")],
    current_user: Annotated[User, Depends(require_permission("tasks.manage"))],
    service: Annotated[TaskService, Depends(get_task_service)],
    task_data: TaskUpdate,
) -> StandardResponse[TaskResponse]:
    """Update a task."""
    update_dict = task_data.model_dump(exclude_unset=True)
    task = service.update_task(task_id, current_user.tenant_id, update_dict, current_user.id)

    if not task:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="TASK_NOT_FOUND",
            message=f"Task with ID {task_id} not found",
        )

    return StandardResponse(
        data=TaskResponse.model_validate(task),
        message="Task updated successfully",
    )


@router.delete(
    "/{task_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Delete task",
    description="Delete a task. Requires tasks.manage permission.",
)
async def delete_task(
    task_id: Annotated[UUID, Path(..., description="Task ID")],
    current_user: Annotated[User, Depends(require_permission("tasks.manage"))],
    service: Annotated[TaskService, Depends(get_task_service)],
) -> None:
    """Delete a task."""
    deleted = service.delete_task(task_id, current_user.tenant_id, current_user.id)
    if not deleted:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="TASK_NOT_FOUND",
            message=f"Task with ID {task_id} not found",
        )


# Checklist endpoints
@router.post(
    "/{task_id}/checklist",
    response_model=StandardResponse[TaskChecklistItemResponse],
    status_code=status.HTTP_201_CREATED,
    summary="Add checklist item",
    description="Add a checklist item to a task. Requires tasks.manage permission.",
)
async def add_checklist_item(
    task_id: Annotated[UUID, Path(..., description="Task ID")],
    current_user: Annotated[User, Depends(require_permission("tasks.manage"))],
    service: Annotated[TaskService, Depends(get_task_service)],
    item_data: TaskChecklistItemCreate,
) -> StandardResponse[TaskChecklistItemResponse]:
    """Add a checklist item to a task."""
    # Verify task exists
    task = service.get_task(task_id, current_user.tenant_id)
    if not task:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="TASK_NOT_FOUND",
            message=f"Task with ID {task_id} not found",
        )

    item = service.add_checklist_item(
        task_id=task_id,
        tenant_id=current_user.tenant_id,
        title=item_data.title,
        order=item_data.order,
    )

    return StandardResponse(
        data=TaskChecklistItemResponse.model_validate(item),
        message="Checklist item added successfully",
    )


@router.get(
    "/{task_id}/checklist",
    response_model=StandardListResponse[TaskChecklistItemResponse],
    status_code=status.HTTP_200_OK,
    summary="List checklist items",
    description="List checklist items for a task. Requires tasks.view permission.",
)
async def list_checklist_items(
    task_id: Annotated[UUID, Path(..., description="Task ID")],
    current_user: Annotated[User, Depends(require_permission("tasks.view"))],
    service: Annotated[TaskService, Depends(get_task_service)],
) -> StandardListResponse[TaskChecklistItemResponse]:
    """List checklist items for a task."""
    items = service.get_checklist_items(task_id, current_user.tenant_id)

    return StandardListResponse(
        data=[TaskChecklistItemResponse.model_validate(i) for i in items],
        meta={
            "total": len(items),
            "page": 1,
            "page_size": max(1, len(items)) if len(items) > 0 else 20,
            "total_pages": 1,
        },
        message="Checklist items retrieved successfully",
    )


@router.put(
    "/checklist/{item_id}",
    response_model=StandardResponse[TaskChecklistItemResponse],
    status_code=status.HTTP_200_OK,
    summary="Update checklist item",
    description="Update a checklist item. Requires tasks.manage permission.",
)
async def update_checklist_item(
    item_id: Annotated[UUID, Path(..., description="Checklist item ID")],
    current_user: Annotated[User, Depends(require_permission("tasks.manage"))],
    service: Annotated[TaskService, Depends(get_task_service)],
    item_data: TaskChecklistItemUpdate,
) -> StandardResponse[TaskChecklistItemResponse]:
    """Update a checklist item."""
    update_dict = item_data.model_dump(exclude_unset=True)
    item = service.update_checklist_item(item_id, current_user.tenant_id, update_dict)

    if not item:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="CHECKLIST_ITEM_NOT_FOUND",
            message=f"Checklist item with ID {item_id} not found",
        )

    return StandardResponse(
        data=TaskChecklistItemResponse.model_validate(item),
        message="Checklist item updated successfully",
    )


@router.delete(
    "/checklist/{item_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Delete checklist item",
    description="Delete a checklist item. Requires tasks.manage permission.",
)
async def delete_checklist_item(
    item_id: Annotated[UUID, Path(..., description="Checklist item ID")],
    current_user: Annotated[User, Depends(require_permission("tasks.manage"))],
    service: Annotated[TaskService, Depends(get_task_service)],
) -> None:
    """Delete a checklist item."""
    deleted = service.delete_checklist_item(item_id, current_user.tenant_id)
    if not deleted:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="CHECKLIST_ITEM_NOT_FOUND",
            message=f"Checklist item with ID {item_id} not found",
        )





"""Templates router for document and notification template management."""

from typing import Annotated
from uuid import UUID

from fastapi import APIRouter, Depends, Path, Query, status
from sqlalchemy.orm import Session

from app.core.auth.dependencies import require_permission
from app.core.db.deps import get_db
from app.core.exceptions import APIException
from app.core.templates.service import TemplateService
from app.models.user import User
from app.schemas.common import StandardListResponse, StandardResponse
from app.schemas.template import (
    TemplateCategoryCreate,
    TemplateCategoryResponse,
    TemplateCreate,
    TemplateRenderRequest,
    TemplateRenderResponse,
    TemplateResponse,
    TemplateUpdate,
    TemplateVersionResponse,
)

router = APIRouter()


def get_template_service(
    db: Annotated[Session, Depends(get_db)],
) -> TemplateService:
    """Dependency to get TemplateService."""
    return TemplateService(db)


# Template endpoints
@router.post(
    "",
    response_model=StandardResponse[TemplateResponse],
    status_code=status.HTTP_201_CREATED,
    summary="Create template",
    description="Create a new template. Requires templates.manage permission.",
)
async def create_template(
    template_data: TemplateCreate,
    current_user: Annotated[User, Depends(require_permission("templates.manage"))],
    service: Annotated[TemplateService, Depends(get_template_service)],
) -> StandardResponse[TemplateResponse]:
    """Create a new template."""
    template = service.create_template(
        template_data=template_data.model_dump(exclude_none=True),
        tenant_id=current_user.tenant_id,
        user_id=current_user.id,
    )

    return StandardResponse(
        data=TemplateResponse.model_validate(template),
        message="Template created successfully",
    )


@router.get(
    "",
    response_model=StandardListResponse[TemplateResponse],
    status_code=status.HTTP_200_OK,
    summary="List templates",
    description="List templates. Requires templates.view permission.",
)
async def list_templates(
    current_user: Annotated[User, Depends(require_permission("templates.view"))],
    service: Annotated[TemplateService, Depends(get_template_service)],
    template_type: str | None = Query(default=None, description="Filter by template type"),
    category: str | None = Query(default=None, description="Filter by category"),
    is_active: bool | None = Query(default=None, description="Filter by active status"),
    page: int = Query(default=1, ge=1, description="Page number"),
    page_size: int = Query(default=20, ge=1, le=100, description="Page size"),
) -> StandardListResponse[TemplateResponse]:
    """List templates."""
    skip = (page - 1) * page_size
    templates = service.get_templates(
        tenant_id=current_user.tenant_id,
        template_type=template_type,
        category=category,
        is_active=is_active,
        skip=skip,
        limit=page_size,
    )

    total = len(templates)
    total_pages = (total + page_size - 1) // page_size if total > 0 else 0

    return StandardListResponse(
        data=[TemplateResponse.model_validate(t) for t in templates],
        total=total,
        page=page,
        page_size=page_size,
        total_pages=total_pages,
        message="Templates retrieved successfully",
    )


@router.get(
    "/{template_id}",
    response_model=StandardResponse[TemplateResponse],
    status_code=status.HTTP_200_OK,
    summary="Get template",
    description="Get a specific template by ID. Requires templates.view permission.",
)
async def get_template(
    template_id: Annotated[UUID, Path(..., description="Template ID")],
    current_user: Annotated[User, Depends(require_permission("templates.view"))],
    service: Annotated[TemplateService, Depends(get_template_service)],
) -> StandardResponse[TemplateResponse]:
    """Get a specific template."""
    template = service.get_template(template_id, current_user.tenant_id)
    if not template:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="TEMPLATE_NOT_FOUND",
            message=f"Template with ID {template_id} not found",
        )

    return StandardResponse(
        data=TemplateResponse.model_validate(template),
        message="Template retrieved successfully",
    )


@router.put(
    "/{template_id}",
    response_model=StandardResponse[TemplateResponse],
    status_code=status.HTTP_200_OK,
    summary="Update template",
    description="Update a template. Requires templates.manage permission.",
)
async def update_template(
    template_id: Annotated[UUID, Path(..., description="Template ID")],
    current_user: Annotated[User, Depends(require_permission("templates.manage"))],
    service: Annotated[TemplateService, Depends(get_template_service)],
    template_data: TemplateUpdate,
) -> StandardResponse[TemplateResponse]:
    """Update a template."""
    template = service.update_template(
        template_id=template_id,
        tenant_id=current_user.tenant_id,
        template_data=template_data.model_dump(exclude_none=True),
    )

    if not template:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="TEMPLATE_NOT_FOUND",
            message=f"Template with ID {template_id} not found",
        )

    return StandardResponse(
        data=TemplateResponse.model_validate(template),
        message="Template updated successfully",
    )


@router.delete(
    "/{template_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Delete template",
    description="Delete a template. Requires templates.manage permission.",
)
async def delete_template(
    template_id: Annotated[UUID, Path(..., description="Template ID")],
    current_user: Annotated[User, Depends(require_permission("templates.manage"))],
    service: Annotated[TemplateService, Depends(get_template_service)],
) -> None:
    """Delete a template."""
    try:
        success = service.delete_template(template_id, current_user.tenant_id)
        if not success:
            raise APIException(
                status_code=status.HTTP_404_NOT_FOUND,
                code="TEMPLATE_NOT_FOUND",
                message=f"Template with ID {template_id} not found",
            )
    except ValueError as e:
        raise APIException(
            status_code=status.HTTP_400_BAD_REQUEST,
            code="TEMPLATE_DELETE_ERROR",
            message=str(e),
        )


@router.get(
    "/{template_id}/versions",
    response_model=StandardListResponse[TemplateVersionResponse],
    status_code=status.HTTP_200_OK,
    summary="Get template versions",
    description="Get template versions. Requires templates.view permission.",
)
async def get_template_versions(
    template_id: Annotated[UUID, Path(..., description="Template ID")],
    current_user: Annotated[User, Depends(require_permission("templates.view"))],
    service: Annotated[TemplateService, Depends(get_template_service)],
) -> StandardListResponse[TemplateVersionResponse]:
    """Get template versions."""
    versions = service.get_template_versions(template_id, current_user.tenant_id)

    return StandardListResponse(
        data=[TemplateVersionResponse.model_validate(v) for v in versions],
        total=len(versions),
        page=1,
        page_size=len(versions),
        total_pages=1,
        message="Template versions retrieved successfully",
    )


@router.post(
    "/{template_id}/render",
    response_model=StandardResponse[TemplateRenderResponse],
    status_code=status.HTTP_200_OK,
    summary="Render template",
    description="Render a template with variables. Requires templates.render permission.",
)
async def render_template(
    template_id: Annotated[UUID, Path(..., description="Template ID")],
    current_user: Annotated[User, Depends(require_permission("templates.render"))],
    service: Annotated[TemplateService, Depends(get_template_service)],
    render_request: TemplateRenderRequest,
) -> StandardResponse[TemplateRenderResponse]:
    """Render a template with variables."""
    try:
        result = service.render_template(
            template_id=template_id,
            tenant_id=current_user.tenant_id,
            variables=render_request.variables,
            format=render_request.format,
        )

        return StandardResponse(
            data=TemplateRenderResponse(**result),
            message="Template rendered successfully",
        )
    except ValueError as e:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="TEMPLATE_NOT_FOUND",
            message=str(e),
        )





"""User management router for CRUD operations."""

from typing import Annotated
from uuid import UUID

from fastapi import APIRouter, Depends, Query, Request, status
from sqlalchemy.orm import Session

from app.core.auth.dependencies import require_permission
from app.core.db.deps import get_db
from app.core.exceptions import (
    raise_bad_request,
    raise_forbidden,
    raise_not_found,
)
from app.core.logging import get_client_info
from app.models.user import User
from app.schemas.common import PaginationMeta, StandardListResponse, StandardResponse
from app.schemas.user import UserCreate, UserUpdate
from app.services.user_service import UserService

router = APIRouter()


@router.get(
    "",
    response_model=StandardListResponse[dict],
    status_code=status.HTTP_200_OK,
    summary="List users",
    description="List all users in the current tenant. Requires auth.manage_users permission.",
    responses={
        200: {"description": "List of users retrieved successfully"},
        403: {
            "description": "Insufficient permissions",
            "content": {
                "application/json": {
                    "example": {
                        "error": {
                            "code": "AUTH_INSUFFICIENT_PERMISSIONS",
                            "message": "Insufficient permissions",
                            "details": {"required_permission": "auth.manage_users"},
                        }
                    }
                }
            },
        },
    },
)
async def list_users(
    current_user: Annotated[User, Depends(require_permission("auth.manage_users"))],
    db: Annotated[Session, Depends(get_db)],
    page: int = Query(default=1, ge=1, description="Page number"),
    page_size: int = Query(default=20, ge=1, le=100, description="Page size"),
) -> StandardListResponse[dict]:
    """
    List all users in the current tenant.

    Requires: auth.manage_users

    Args:
        current_user: Current authenticated user (must have auth.manage_users).
        db: Database session.
        page: Page number (default: 1).
        page_size: Page size (default: 20, max: 100).

    Returns:
        StandardListResponse with list of users and pagination metadata.

    Raises:
        APIException: If user lacks permission.
    """
    user_service = UserService(db)
    skip = (page - 1) * page_size
    users, total = user_service.list_users(
        tenant_id=current_user.tenant_id, skip=skip, limit=page_size
    )

    total_pages = (total + page_size - 1) // page_size if total > 0 else 0

    # Return user dicts directly (UserResponse has forward references that need model_rebuild)
    return StandardListResponse(
        data=users,
        meta=PaginationMeta(
            total=total, page=page, page_size=page_size, total_pages=total_pages
        ),
    )


@router.post(
    "",
    response_model=StandardResponse[dict],
    status_code=status.HTTP_201_CREATED,
    summary="Create user",
    description="Create a new user. Requires auth.manage_users permission.",
    responses={
        201: {"description": "User created successfully"},
        400: {
            "description": "Invalid request or user already exists",
            "content": {
                "application/json": {
                    "example": {
                        "error": {
                            "code": "USER_ALREADY_EXISTS",
                            "message": "User with email 'user@example.com' already exists",
                            "details": None,
                        }
                    }
                }
            },
        },
        403: {
            "description": "Insufficient permissions",
            "content": {
                "application/json": {
                    "example": {
                        "error": {
                            "code": "AUTH_INSUFFICIENT_PERMISSIONS",
                            "message": "Insufficient permissions",
                            "details": {"required_permission": "auth.manage_users"},
                        }
                    }
                }
            },
        },
    },
)
async def create_user(
    user_data: UserCreate,
    request: Request,
    current_user: Annotated[User, Depends(require_permission("auth.manage_users"))],
    db: Annotated[Session, Depends(get_db)],
) -> StandardResponse[dict]:
    """
    Create a new user.

    Requires: auth.manage_users

    Args:
        user_data: User creation data.
        current_user: Current authenticated user (must have auth.manage_users).
        db: Database session.

    Returns:
        StandardResponse with created user data.

    Raises:
        APIException: If user already exists or validation fails.
    """
    # Ensure user is created in the same tenant as current user
    if user_data.tenant_id != current_user.tenant_id:
        raise_forbidden(
            code="AUTH_TENANT_MISMATCH",
            message="Cannot create user in different tenant",
        )

    user_service = UserService(db)
    ip_address, user_agent = get_client_info(request)
    try:
        user_dict = user_service.create_user(
            user_data,
            created_by=current_user.id,
            ip_address=ip_address,
            user_agent=user_agent,
        )
        user = user_service.get_user(user_dict["id"])
        return StandardResponse(data=user)
    except ValueError as e:
        raise_bad_request(code="USER_ALREADY_EXISTS", message=str(e))


@router.get(
    "/{user_id}",
    response_model=StandardResponse[dict],
    status_code=status.HTTP_200_OK,
    summary="Get user",
    description="Get user by ID. Requires auth.manage_users permission.",
    responses={
        200: {"description": "User retrieved successfully"},
        403: {
            "description": "Insufficient permissions",
            "content": {
                "application/json": {
                    "example": {
                        "error": {
                            "code": "AUTH_INSUFFICIENT_PERMISSIONS",
                            "message": "Insufficient permissions",
                            "details": {"required_permission": "auth.manage_users"},
                        }
                    }
                }
            },
        },
        404: {
            "description": "User not found",
            "content": {
                "application/json": {
                    "example": {
                        "error": {
                            "code": "USER_NOT_FOUND",
                            "message": "User not found",
                            "details": None,
                        }
                    }
                }
            },
        },
    },
)
async def get_user(
    user_id: str,
    current_user: Annotated[User, Depends(require_permission("auth.manage_users"))],
    db: Annotated[Session, Depends(get_db)],
) -> StandardResponse[dict]:
    """
    Get user by ID.

    Requires: auth.manage_users

    Args:
        user_id: User UUID.
        current_user: Current authenticated user (must have auth.manage_users).
        db: Database session.

    Returns:
        StandardResponse with user data.

    Raises:
        APIException: If user not found or lacks permission.
    """
    try:
        user_uuid = UUID(user_id)
    except ValueError:
        raise_bad_request(code="INVALID_UUID", message="Invalid user ID format")

    user_service = UserService(db)
    user = user_service.get_user(user_uuid)

    if not user:
        raise_not_found("User", user_id)

    # Verify tenant access
    if user["tenant_id"] != current_user.tenant_id:
        raise_forbidden(
            code="AUTH_TENANT_MISMATCH",
            message="Cannot access user from different tenant",
        )

    return StandardResponse(data=user)


@router.patch(
    "/{user_id}",
    response_model=StandardResponse[dict],
    status_code=status.HTTP_200_OK,
    summary="Update user",
    description="Update user by ID. Requires auth.manage_users permission.",
    responses={
        200: {"description": "User updated successfully"},
        400: {
            "description": "Invalid request or user already exists",
            "content": {
                "application/json": {
                    "example": {
                        "error": {
                            "code": "USER_ALREADY_EXISTS",
                            "message": "User with email 'user@example.com' already exists",
                            "details": None,
                        }
                    }
                }
            },
        },
        403: {
            "description": "Insufficient permissions",
            "content": {
                "application/json": {
                    "example": {
                        "error": {
                            "code": "AUTH_INSUFFICIENT_PERMISSIONS",
                            "message": "Insufficient permissions",
                            "details": {"required_permission": "auth.manage_users"},
                        }
                    }
                }
            },
        },
        404: {
            "description": "User not found",
            "content": {
                "application/json": {
                    "example": {
                        "error": {
                            "code": "USER_NOT_FOUND",
                            "message": "User not found",
                            "details": None,
                        }
                    }
                }
            },
        },
    },
)
async def update_user(
    user_id: str,
    user_data: UserUpdate,
    request: Request,
    current_user: Annotated[User, Depends(require_permission("auth.manage_users"))],
    db: Annotated[Session, Depends(get_db)],
) -> StandardResponse[dict]:
    """
    Update user by ID.

    Requires: auth.manage_users

    Args:
        user_id: User UUID.
        user_data: User update data.
        current_user: Current authenticated user (must have auth.manage_users).
        db: Database session.

    Returns:
        StandardResponse with updated user data.

    Raises:
        APIException: If user not found, validation fails, or lacks permission.
    """
    try:
        user_uuid = UUID(user_id)
    except ValueError:
        raise_bad_request(code="INVALID_UUID", message="Invalid user ID format")

    user_service = UserService(db)
    existing_user = user_service.get_user(user_uuid)

    if not existing_user:
        raise_not_found("User", user_id)

    # Verify tenant access
    if existing_user["tenant_id"] != current_user.tenant_id:
        raise_forbidden(
            code="AUTH_TENANT_MISMATCH",
            message="Cannot access user from different tenant",
        )

    ip_address, user_agent = get_client_info(request)
    try:
        updated_user = user_service.update_user(
            user_uuid,
            user_data,
            updated_by=current_user.id,
            ip_address=ip_address,
            user_agent=user_agent,
        )
        if not updated_user:
            raise_not_found("User", user_id)
        return StandardResponse(data=updated_user)
    except ValueError as e:
        raise_bad_request(code="USER_ALREADY_EXISTS", message=str(e))


@router.delete(
    "/{user_id}",
    response_model=StandardResponse[dict],
    status_code=status.HTTP_200_OK,
    summary="Delete user (soft delete)",
    description="Soft delete user by setting is_active=False. Requires auth.manage_users permission.",
    responses={
        200: {"description": "User deleted successfully"},
        403: {
            "description": "Insufficient permissions",
            "content": {
                "application/json": {
                    "example": {
                        "error": {
                            "code": "AUTH_INSUFFICIENT_PERMISSIONS",
                            "message": "Insufficient permissions",
                            "details": {"required_permission": "auth.manage_users"},
                        }
                    }
                }
            },
        },
        404: {
            "description": "User not found",
            "content": {
                "application/json": {
                    "example": {
                        "error": {
                            "code": "USER_NOT_FOUND",
                            "message": "User not found",
                            "details": None,
                        }
                    }
                }
            },
        },
    },
)
async def delete_user(
    user_id: str,
    request: Request,
    current_user: Annotated[User, Depends(require_permission("auth.manage_users"))],
    db: Annotated[Session, Depends(get_db)],
) -> StandardResponse[dict]:
    """
    Soft delete user by setting is_active=False.

    Requires: auth.manage_users

    Args:
        user_id: User UUID.
        current_user: Current authenticated user (must have auth.manage_users).
        db: Database session.

    Returns:
        StandardResponse with success message.

    Raises:
        APIException: If user not found or lacks permission.
    """
    try:
        user_uuid = UUID(user_id)
    except ValueError:
        raise_bad_request(code="INVALID_UUID", message="Invalid user ID format")

    user_service = UserService(db)
    existing_user = user_service.get_user(user_uuid)

    if not existing_user:
        raise_not_found("User", user_id)

    # Verify tenant access
    if existing_user["tenant_id"] != current_user.tenant_id:
        raise_forbidden(
            code="AUTH_TENANT_MISMATCH",
            message="Cannot access user from different tenant",
        )

    ip_address, user_agent = get_client_info(request)
    success = user_service.delete_user(
        user_uuid,
        deactivated_by=current_user.id,
        ip_address=ip_address,
        user_agent=user_agent,
    )
    if not success:
        raise_not_found("User", user_id)

    return StandardResponse(data={"message": "User deleted successfully"})

"""Views router for saved filters and custom views management."""

from typing import Annotated
from uuid import UUID

from fastapi import APIRouter, Depends, Path, Query, status
from sqlalchemy.orm import Session

from app.core.auth.dependencies import require_permission
from app.core.db.deps import get_db
from app.core.exceptions import APIException
from app.core.views.service import ViewService
from app.models.user import User
from app.schemas.common import StandardListResponse, StandardResponse
from app.schemas.view import (
    CustomViewCreate,
    CustomViewResponse,
    CustomViewUpdate,
    SavedFilterCreate,
    SavedFilterResponse,
    SavedFilterUpdate,
    ViewShareCreate,
    ViewShareResponse,
)

router = APIRouter()


def get_view_service(
    db: Annotated[Session, Depends(get_db)],
) -> ViewService:
    """Dependency to get ViewService."""
    return ViewService(db)


# Saved Filter endpoints
@router.post(
    "/filters",
    response_model=StandardResponse[SavedFilterResponse],
    status_code=status.HTTP_201_CREATED,
    summary="Create saved filter",
    description="Create a new saved filter. Requires views.manage permission.",
)
async def create_saved_filter(
    filter_data: SavedFilterCreate,
    current_user: Annotated[User, Depends(require_permission("views.manage"))],
    service: Annotated[ViewService, Depends(get_view_service)],
) -> StandardResponse[SavedFilterResponse]:
    """Create a new saved filter."""
    filter_obj = service.create_saved_filter(
        filter_data=filter_data.model_dump(exclude_none=True),
        tenant_id=current_user.tenant_id,
        user_id=current_user.id,
    )

    return StandardResponse(
        data=SavedFilterResponse.model_validate(filter_obj),
        message="Saved filter created successfully",
    )


@router.get(
    "/filters",
    response_model=StandardListResponse[SavedFilterResponse],
    status_code=status.HTTP_200_OK,
    summary="List saved filters",
    description="List saved filters. Requires views.view permission.",
)
async def list_saved_filters(
    current_user: Annotated[User, Depends(require_permission("views.view"))],
    service: Annotated[ViewService, Depends(get_view_service)],
    module: str | None = Query(default=None, description="Filter by module"),
    is_shared: bool | None = Query(default=None, description="Filter by shared status"),
    page: int = Query(default=1, ge=1, description="Page number"),
    page_size: int = Query(default=20, ge=1, le=100, description="Page size"),
) -> StandardListResponse[SavedFilterResponse]:
    """List saved filters."""
    skip = (page - 1) * page_size
    filters = service.get_saved_filters(
        tenant_id=current_user.tenant_id,
        module=module,
        user_id=current_user.id,
        is_shared=is_shared,
        skip=skip,
        limit=page_size,
    )

    total = len(filters)
    total_pages = (total + page_size - 1) // page_size if total > 0 else 0

    return StandardListResponse(
        data=[SavedFilterResponse.model_validate(f) for f in filters],
        total=total,
        page=page,
        page_size=page_size,
        total_pages=total_pages,
        message="Saved filters retrieved successfully",
    )


@router.get(
    "/filters/{filter_id}",
    response_model=StandardResponse[SavedFilterResponse],
    status_code=status.HTTP_200_OK,
    summary="Get saved filter",
    description="Get a specific saved filter by ID. Requires views.view permission.",
)
async def get_saved_filter(
    filter_id: Annotated[UUID, Path(..., description="Saved filter ID")],
    current_user: Annotated[User, Depends(require_permission("views.view"))],
    service: Annotated[ViewService, Depends(get_view_service)],
) -> StandardResponse[SavedFilterResponse]:
    """Get a specific saved filter."""
    filter_obj = service.get_saved_filter(filter_id, current_user.tenant_id)
    if not filter_obj:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="FILTER_NOT_FOUND",
            message=f"Saved filter with ID {filter_id} not found",
        )

    return StandardResponse(
        data=SavedFilterResponse.model_validate(filter_obj),
        message="Saved filter retrieved successfully",
    )


@router.put(
    "/filters/{filter_id}",
    response_model=StandardResponse[SavedFilterResponse],
    status_code=status.HTTP_200_OK,
    summary="Update saved filter",
    description="Update a saved filter. Requires views.manage permission.",
)
async def update_saved_filter(
    filter_id: Annotated[UUID, Path(..., description="Saved filter ID")],
    current_user: Annotated[User, Depends(require_permission("views.manage"))],
    service: Annotated[ViewService, Depends(get_view_service)],
    filter_data: SavedFilterUpdate,
) -> StandardResponse[SavedFilterResponse]:
    """Update a saved filter."""
    filter_obj = service.update_saved_filter(
        filter_id=filter_id,
        tenant_id=current_user.tenant_id,
        filter_data=filter_data.model_dump(exclude_none=True),
    )

    if not filter_obj:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="FILTER_NOT_FOUND",
            message=f"Saved filter with ID {filter_id} not found",
        )

    return StandardResponse(
        data=SavedFilterResponse.model_validate(filter_obj),
        message="Saved filter updated successfully",
    )


@router.delete(
    "/filters/{filter_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Delete saved filter",
    description="Delete a saved filter. Requires views.manage permission.",
)
async def delete_saved_filter(
    filter_id: Annotated[UUID, Path(..., description="Saved filter ID")],
    current_user: Annotated[User, Depends(require_permission("views.manage"))],
    service: Annotated[ViewService, Depends(get_view_service)],
) -> None:
    """Delete a saved filter."""
    success = service.delete_saved_filter(filter_id, current_user.tenant_id)
    if not success:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="FILTER_NOT_FOUND",
            message=f"Saved filter with ID {filter_id} not found",
        )


# Custom View endpoints
@router.post(
    "/views",
    response_model=StandardResponse[CustomViewResponse],
    status_code=status.HTTP_201_CREATED,
    summary="Create custom view",
    description="Create a new custom view. Requires views.manage permission.",
)
async def create_custom_view(
    view_data: CustomViewCreate,
    current_user: Annotated[User, Depends(require_permission("views.manage"))],
    service: Annotated[ViewService, Depends(get_view_service)],
) -> StandardResponse[CustomViewResponse]:
    """Create a new custom view."""
    view = service.create_custom_view(
        view_data=view_data.model_dump(exclude_none=True),
        tenant_id=current_user.tenant_id,
        user_id=current_user.id,
    )

    return StandardResponse(
        data=CustomViewResponse.model_validate(view),
        message="Custom view created successfully",
    )


@router.get(
    "/views",
    response_model=StandardListResponse[CustomViewResponse],
    status_code=status.HTTP_200_OK,
    summary="List custom views",
    description="List custom views. Requires views.view permission.",
)
async def list_custom_views(
    current_user: Annotated[User, Depends(require_permission("views.view"))],
    service: Annotated[ViewService, Depends(get_view_service)],
    module: str | None = Query(default=None, description="Filter by module"),
    is_shared: bool | None = Query(default=None, description="Filter by shared status"),
    page: int = Query(default=1, ge=1, description="Page number"),
    page_size: int = Query(default=20, ge=1, le=100, description="Page size"),
) -> StandardListResponse[CustomViewResponse]:
    """List custom views."""
    skip = (page - 1) * page_size
    views = service.get_custom_views(
        tenant_id=current_user.tenant_id,
        module=module,
        user_id=current_user.id,
        is_shared=is_shared,
        skip=skip,
        limit=page_size,
    )

    total = len(views)
    total_pages = (total + page_size - 1) // page_size if total > 0 else 0

    return StandardListResponse(
        data=[CustomViewResponse.model_validate(v) for v in views],
        total=total,
        page=page,
        page_size=page_size,
        total_pages=total_pages,
        message="Custom views retrieved successfully",
    )


@router.get(
    "/views/{view_id}",
    response_model=StandardResponse[CustomViewResponse],
    status_code=status.HTTP_200_OK,
    summary="Get custom view",
    description="Get a specific custom view by ID. Requires views.view permission.",
)
async def get_custom_view(
    view_id: Annotated[UUID, Path(..., description="Custom view ID")],
    current_user: Annotated[User, Depends(require_permission("views.view"))],
    service: Annotated[ViewService, Depends(get_view_service)],
) -> StandardResponse[CustomViewResponse]:
    """Get a specific custom view."""
    view = service.get_custom_view(view_id, current_user.tenant_id)
    if not view:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="VIEW_NOT_FOUND",
            message=f"Custom view with ID {view_id} not found",
        )

    return StandardResponse(
        data=CustomViewResponse.model_validate(view),
        message="Custom view retrieved successfully",
    )


@router.put(
    "/views/{view_id}",
    response_model=StandardResponse[CustomViewResponse],
    status_code=status.HTTP_200_OK,
    summary="Update custom view",
    description="Update a custom view. Requires views.manage permission.",
)
async def update_custom_view(
    view_id: Annotated[UUID, Path(..., description="Custom view ID")],
    current_user: Annotated[User, Depends(require_permission("views.manage"))],
    service: Annotated[ViewService, Depends(get_view_service)],
    view_data: CustomViewUpdate,
) -> StandardResponse[CustomViewResponse]:
    """Update a custom view."""
    view = service.update_custom_view(
        view_id=view_id,
        tenant_id=current_user.tenant_id,
        view_data=view_data.model_dump(exclude_none=True),
    )

    if not view:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="VIEW_NOT_FOUND",
            message=f"Custom view with ID {view_id} not found",
        )

    return StandardResponse(
        data=CustomViewResponse.model_validate(view),
        message="Custom view updated successfully",
    )


@router.delete(
    "/views/{view_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Delete custom view",
    description="Delete a custom view. Requires views.manage permission.",
)
async def delete_custom_view(
    view_id: Annotated[UUID, Path(..., description="Custom view ID")],
    current_user: Annotated[User, Depends(require_permission("views.manage"))],
    service: Annotated[ViewService, Depends(get_view_service)],
) -> None:
    """Delete a custom view."""
    success = service.delete_custom_view(view_id, current_user.tenant_id)
    if not success:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="VIEW_NOT_FOUND",
            message=f"Custom view with ID {view_id} not found",
        )


# View Share endpoints
@router.post(
    "/filters/{filter_id}/share",
    response_model=StandardResponse[ViewShareResponse],
    status_code=status.HTTP_201_CREATED,
    summary="Share filter",
    description="Share a filter with other users. Requires views.share permission.",
)
async def share_filter(
    filter_id: Annotated[UUID, Path(..., description="Filter ID")],
    current_user: Annotated[User, Depends(require_permission("views.share"))],
    service: Annotated[ViewService, Depends(get_view_service)],
    share_data: ViewShareCreate,
) -> StandardResponse[ViewShareResponse]:
    """Share a filter with other users."""
    share = service.share_filter(
        filter_id=filter_id,
        tenant_id=current_user.tenant_id,
        share_data=share_data.model_dump(exclude_none=True),
    )

    return StandardResponse(
        data=ViewShareResponse.model_validate(share),
        message="Filter shared successfully",
    )


@router.post(
    "/views/{view_id}/share",
    response_model=StandardResponse[ViewShareResponse],
    status_code=status.HTTP_201_CREATED,
    summary="Share view",
    description="Share a view with other users. Requires views.share permission.",
)
async def share_view(
    view_id: Annotated[UUID, Path(..., description="View ID")],
    current_user: Annotated[User, Depends(require_permission("views.share"))],
    service: Annotated[ViewService, Depends(get_view_service)],
    share_data: ViewShareCreate,
) -> StandardResponse[ViewShareResponse]:
    """Share a view with other users."""
    share = service.share_view(
        view_id=view_id,
        tenant_id=current_user.tenant_id,
        share_data=share_data.model_dump(exclude_none=True),
    )

    return StandardResponse(
        data=ViewShareResponse.model_validate(share),
        message="View shared successfully",
    )





"""Workflows router for workflow management."""

from typing import Annotated
from uuid import UUID

from fastapi import APIRouter, Depends, Path, Query, status
from sqlalchemy.orm import Session

from app.core.auth.dependencies import require_permission
from app.core.db.deps import get_db
from app.core.exceptions import APIException
from app.core.tasks.workflow_service import WorkflowService
from app.models.user import User
from app.schemas.common import StandardListResponse, StandardResponse
from app.schemas.task import (
    WorkflowCreate,
    WorkflowExecutionCreate,
    WorkflowExecutionResponse,
    WorkflowResponse,
    WorkflowStepCreate,
    WorkflowStepResponse,
    WorkflowUpdate,
)

router = APIRouter()


def get_workflow_service(db: Annotated[Session, Depends(get_db)]) -> WorkflowService:
    """Dependency to get WorkflowService."""
    return WorkflowService(db)


@router.post(
    "",
    response_model=StandardResponse[WorkflowResponse],
    status_code=status.HTTP_201_CREATED,
    summary="Create workflow",
    description="Create a new workflow. Requires workflows.manage permission.",
)
async def create_workflow(
    workflow_data: WorkflowCreate,
    current_user: Annotated[User, Depends(require_permission("workflows.manage"))],
    service: Annotated[WorkflowService, Depends(get_workflow_service)],
) -> StandardResponse[WorkflowResponse]:
    """Create a new workflow."""
    workflow = service.create_workflow(
        name=workflow_data.name,
        tenant_id=current_user.tenant_id,
        description=workflow_data.description,
        definition=workflow_data.definition,
        enabled=workflow_data.enabled,
        metadata=workflow_data.metadata,
    )

    return StandardResponse(
        data=WorkflowResponse.model_validate(workflow),
        message="Workflow created successfully",
    )


@router.get(
    "",
    response_model=StandardListResponse[WorkflowResponse],
    status_code=status.HTTP_200_OK,
    summary="List workflows",
    description="List workflows. Requires workflows.view permission.",
)
async def list_workflows(
    current_user: Annotated[User, Depends(require_permission("workflows.view"))],
    service: Annotated[WorkflowService, Depends(get_workflow_service)],
    page: int = Query(default=1, ge=1, description="Page number"),
    page_size: int = Query(default=20, ge=1, le=100, description="Page size"),
    enabled_only: bool = Query(default=False, description="Only return enabled workflows"),
) -> StandardListResponse[WorkflowResponse]:
    """List workflows."""
    skip = (page - 1) * page_size
    workflows = service.get_workflows(
        tenant_id=current_user.tenant_id,
        enabled_only=enabled_only,
        skip=skip,
        limit=page_size,
    )
    total = len(workflows)  # TODO: Add count method to repository

    total_pages = (total + page_size - 1) // page_size if total > 0 else 0

    return StandardListResponse(
        data=[WorkflowResponse.model_validate(w) for w in workflows],
        total=total,
        page=page,
        page_size=page_size,
        total_pages=total_pages,
        message="Workflows retrieved successfully",
    )


@router.get(
    "/{workflow_id}",
    response_model=StandardResponse[WorkflowResponse],
    status_code=status.HTTP_200_OK,
    summary="Get workflow",
    description="Get a specific workflow by ID. Requires workflows.view permission.",
)
async def get_workflow(
    workflow_id: Annotated[UUID, Path(..., description="Workflow ID")],
    current_user: Annotated[User, Depends(require_permission("workflows.view"))],
    service: Annotated[WorkflowService, Depends(get_workflow_service)],
) -> StandardResponse[WorkflowResponse]:
    """Get a specific workflow."""
    workflow = service.get_workflow(workflow_id, current_user.tenant_id)
    if not workflow:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="WORKFLOW_NOT_FOUND",
            message=f"Workflow with ID {workflow_id} not found",
        )

    return StandardResponse(
        data=WorkflowResponse.model_validate(workflow),
        message="Workflow retrieved successfully",
    )


@router.put(
    "/{workflow_id}",
    response_model=StandardResponse[WorkflowResponse],
    status_code=status.HTTP_200_OK,
    summary="Update workflow",
    description="Update a workflow. Requires workflows.manage permission.",
)
async def update_workflow(
    workflow_id: Annotated[UUID, Path(..., description="Workflow ID")],
    current_user: Annotated[User, Depends(require_permission("workflows.manage"))],
    service: Annotated[WorkflowService, Depends(get_workflow_service)],
    workflow_data: WorkflowUpdate,
) -> StandardResponse[WorkflowResponse]:
    """Update a workflow."""
    update_dict = workflow_data.model_dump(exclude_unset=True)
    workflow = service.update_workflow(workflow_id, current_user.tenant_id, update_dict)

    if not workflow:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="WORKFLOW_NOT_FOUND",
            message=f"Workflow with ID {workflow_id} not found",
        )

    return StandardResponse(
        data=WorkflowResponse.model_validate(workflow),
        message="Workflow updated successfully",
    )


@router.delete(
    "/{workflow_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Delete workflow",
    description="Delete a workflow. Requires workflows.manage permission.",
)
async def delete_workflow(
    workflow_id: Annotated[UUID, Path(..., description="Workflow ID")],
    current_user: Annotated[User, Depends(require_permission("workflows.manage"))],
    service: Annotated[WorkflowService, Depends(get_workflow_service)],
) -> None:
    """Delete a workflow."""
    deleted = service.delete_workflow(workflow_id, current_user.tenant_id)
    if not deleted:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="WORKFLOW_NOT_FOUND",
            message=f"Workflow with ID {workflow_id} not found",
        )


@router.post(
    "/{workflow_id}/steps",
    response_model=StandardResponse[WorkflowStepResponse],
    status_code=status.HTTP_201_CREATED,
    summary="Create workflow step",
    description="Create a workflow step. Requires workflows.manage permission.",
)
async def create_workflow_step(
    workflow_id: Annotated[UUID, Path(..., description="Workflow ID")],
    current_user: Annotated[User, Depends(require_permission("workflows.manage"))],
    service: Annotated[WorkflowService, Depends(get_workflow_service)],
    step_data: WorkflowStepCreate,
) -> StandardResponse[WorkflowStepResponse]:
    """Create a workflow step."""
    # Verify workflow exists
    workflow = service.get_workflow(workflow_id, current_user.tenant_id)
    if not workflow:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            code="WORKFLOW_NOT_FOUND",
            message=f"Workflow with ID {workflow_id} not found",
        )

    step = service.create_workflow_step(
        workflow_id=workflow_id,
        tenant_id=current_user.tenant_id,
        name=step_data.name,
        step_type=step_data.step_type,
        order=step_data.order,
        config=step_data.config,
        transitions=step_data.transitions,
    )

    return StandardResponse(
        data=WorkflowStepResponse.model_validate(step),
        message="Workflow step created successfully",
    )


@router.get(
    "/{workflow_id}/steps",
    response_model=StandardListResponse[WorkflowStepResponse],
    status_code=status.HTTP_200_OK,
    summary="List workflow steps",
    description="List steps for a workflow. Requires workflows.view permission.",
)
async def list_workflow_steps(
    workflow_id: Annotated[UUID, Path(..., description="Workflow ID")],
    current_user: Annotated[User, Depends(require_permission("workflows.view"))],
    service: Annotated[WorkflowService, Depends(get_workflow_service)],
) -> StandardListResponse[WorkflowStepResponse]:
    """List workflow steps."""
    steps = service.get_workflow_steps(workflow_id, current_user.tenant_id)

    return StandardListResponse(
        data=[WorkflowStepResponse.model_validate(s) for s in steps],
        total=len(steps),
        page=1,
        page_size=len(steps),
        total_pages=1,
        message="Workflow steps retrieved successfully",
    )


@router.post(
    "/{workflow_id}/execute",
    response_model=StandardResponse[WorkflowExecutionResponse],
    status_code=status.HTTP_201_CREATED,
    summary="Start workflow execution",
    description="Start a workflow execution. Requires workflows.manage permission.",
)
async def start_workflow_execution(
    workflow_id: Annotated[UUID, Path(..., description="Workflow ID")],
    current_user: Annotated[User, Depends(require_permission("workflows.manage"))],
    service: Annotated[WorkflowService, Depends(get_workflow_service)],
    execution_data: WorkflowExecutionCreate,
) -> StandardResponse[WorkflowExecutionResponse]:
    """Start a workflow execution."""
    execution = service.start_workflow_execution(
        workflow_id=workflow_id,
        tenant_id=current_user.tenant_id,
        entity_type=execution_data.entity_type,
        entity_id=execution_data.entity_id,
        execution_data=execution_data.execution_data,
    )

    return StandardResponse(
        data=WorkflowExecutionResponse.model_validate(execution),
        message="Workflow execution started successfully",
    )





"""API v1 router aggregation."""

from fastapi import APIRouter

from app.api.v1 import (
    activities,
    approvals,
    auth,
    automation,
    calendar,
    comments,
    config,
    files,
    import_export,
    integrations,
    notifications,
    preferences,
    pubsub,
    reporting,
    search,
    tags,
    tasks,
    templates,
    users,
    views,
    workflows,
)
from app.modules.products.api import router as products_router

api_router = APIRouter()

# Include module routers
api_router.include_router(auth.router, prefix="/auth", tags=["auth"])
api_router.include_router(users.router, prefix="/users", tags=["users"])
api_router.include_router(products_router, prefix="/products", tags=["products"])
api_router.include_router(config.router, prefix="/config", tags=["config"])
api_router.include_router(pubsub.router, prefix="/pubsub", tags=["pubsub"])
api_router.include_router(automation.router, prefix="/automation", tags=["automation"])
api_router.include_router(preferences.router, prefix="/preferences", tags=["preferences"])
api_router.include_router(reporting.router, prefix="/reporting", tags=["reporting"])
api_router.include_router(notifications.router, prefix="/notifications", tags=["notifications"])
api_router.include_router(files.router, prefix="/files", tags=["files"])
api_router.include_router(activities.router, prefix="/activities", tags=["activities"])
api_router.include_router(tags.router, prefix="/tags", tags=["tags"])
api_router.include_router(tasks.router, prefix="/tasks", tags=["tasks"])
api_router.include_router(workflows.router, prefix="/workflows", tags=["workflows"])
api_router.include_router(search.router, prefix="/search", tags=["search"])
api_router.include_router(integrations.router, prefix="/integrations", tags=["integrations"])
api_router.include_router(calendar.router, prefix="/calendar", tags=["calendar"])
api_router.include_router(import_export.router, prefix="/import-export", tags=["import-export"])
api_router.include_router(views.router, prefix="/views", tags=["views"])
api_router.include_router(approvals.router, prefix="/approvals", tags=["approvals"])
api_router.include_router(templates.router, prefix="/templates", tags=["templates"])
api_router.include_router(comments.router, prefix="/comments", tags=["comments"])


